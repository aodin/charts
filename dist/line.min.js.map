{
  "version": 3,
  "sources": ["external-global-plugin:d3", "../src/line.js", "../src/animation.js", "../src/chart.js", "../src/colors.js", "../src/layout.js", "../src/parsers.js", "../src/text.js", "../src/throttle.js", "../src/ticks.js", "../src/tooltip.js"],
  "sourcesContent": ["module.exports = d3", "/*\nLine chart\n*/\nimport * as d3 from \"d3\";\n\nimport { animatedDashArray, animatedDashOffset } from \"./animation\";\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { throttle } from \"./throttle\";\nimport { maxLabelSize } from \"./ticks\";\nimport { placeTooltip, placeTooltipTop, pageXY } from \"./tooltip\";\n\nexport { parse3dArray, parseTimeSeries3dArray, placeTooltip, placeTooltipTop };\n\n// Clip paths require a unique ID\nlet uniqueID = 0;\n\nfunction getLength(elem) {\n  // Not all DOMs support getTotalLength\n  return elem.getTotalLength ? elem.getTotalLength() : null;\n}\n\nexport class LineChart extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Line charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      LAYOUT: {},\n      DURATION_MS: 500,\n      FPS: 48,\n      Y_AXIS_RIGHT: false,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      HIGHLIGHT_STROKE_WIDTH: 2.0, // Width when highlighted\n      STROKE_WIDTH: 1.5, // Width when not highlighted\n      DOT_RADIUS: 3.0, // Radius of the dot\n      HIDE_EMPTY_CHART: false,\n      COLORS: d3.schemeCategory10, // TODO There's no way to change the default yet\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    this.patterns = {}; // {z: dash array pattern}\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Chained config methods */\n  setPattern(z, pattern) {\n    // Set the dash array pattern for a z item\n    this.patterns[z] = pattern;\n    return this;\n  }\n\n  hideIfEmpty() {\n    this.config.HIDE_EMPTY_CHART = true;\n    return this;\n  }\n  /* End chained config methods */\n\n  getPattern(z) {\n    // Returns an array of the z item pattern, with unset patterns as an empty array\n    return this.patterns[z] || [];\n  }\n\n  getDashArrayAttr(z) {\n    // Return the z item pattern as a string or null\n    return this.getPattern(z).length ? this.getPattern(z).join(\" \") : null;\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.Z, (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get zVisible() {\n    const visible = new d3.InternSet(this.Z);\n    this.hidden.forEach((z) => visible.delete(z));\n    return Array.from(visible);\n  }\n\n  get visibleData() {\n    // TODO memoization\n    return d3.filter(this.data, (d) => !this.hidden.has(d.z));\n  }\n\n  get empty() {\n    // Returns True if there are no visible items on the chart\n    return this.zVisible.length === 0;\n  }\n\n  get xDomain() {\n    // By default, don't re-calculate the x-axis\n    return d3.extent(d3.map(this.data, (d) => d.x));\n  }\n\n  get yDomain() {\n    // TODO memoization\n    if (this.visibleData.length) {\n      return d3.extent(d3.map(this.visibleData, (d) => d.y));\n    } else {\n      return d3.extent(d3.map(this.data, (d) => d.y));\n    }\n  }\n\n  get xScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0]);\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(3).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    if (this.config.Y_AXIS_RIGHT) {\n      g.call(d3.axisRight(y).tickSize(0).tickFormat(this.yFormat));\n    } else {\n      g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n    }\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    // Another option for \"zero state\" is to set the tick size to zero\n    // const tickSize = this.empty ? 0 : -this.layout.innerWidth;\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"))\n      .selectAll(\".tick\")\n      .each(function (d) {\n        d3.select(this).classed(\"zero\", d === 0);\n      });\n    // The following throws an error:\n    // .classed(\"zero\", d => d === 0)\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced\n      this.layout.pad.left = 5;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // Set a new clip path ID whenever the chart is rendered\n    const clipPathID = `line-clip-path-${uniqueID++}`;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(selector, this.config.LAYOUT);\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    this.x = this.xScale;\n    this.y = this.yScale;\n\n    // Start with the SVG visible - this can be set to 0 for \"fade in\"\n    this.svg.attr(\"opacity\", 1.0);\n\n    // Create a clip path to hide any overflow content\n    this.svg\n      .append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", clipPathID)\n      .append(\"rect\")\n      .attr(\"width\", this.layout.width)\n      .attr(\"height\", this.layout.height);\n\n    this.svg.attr(\"clip-path\", `url(#${clipPathID})`);\n\n    // First items drawn are lower layers\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    this.gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    let yTransform = `translate(${this.layout.pad.left - this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    if (this.config.Y_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.pad.left + this.layout.innerWidth + this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    }\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\"transform\", yTransform);\n\n    const grouping = d3.group(this.data, (d) => d.z);\n\n    this.paths = this.gInner\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH)\n      .selectAll(\"path\")\n      .data(grouping)\n      .join(\"path\");\n\n    // Dot - shows nearest point during pointer events\n    this.dot = this.gInner\n      .append(\"g\")\n      .attr(\"class\", \"dot\")\n      .style(\"display\", \"none\");\n    this.circle = this.dot.append(\"circle\").attr(\"r\", this.config.DOT_RADIUS);\n\n    // The initial line drawing animation relies on manipulating stroke attributes,\n    // which can change whenever we redraw lines, so we'll only do the draw animation\n    // once and all subsequent updates will just use a solid stroke\n    this.previousUpdate = false;\n\n    // Visibility and opacity will be changed when the chart is in a \"zero state\"\n    const isEmpty = this.empty;\n\n    // Set initial state\n    this.gx.call(this.xAxis.bind(this), this.x).attr(\"opacity\", 1.0);\n\n    this.gy\n      .call(this.yAxis.bind(this), this.y)\n      .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n\n    this.gGrid.call(this.grid.bind(this), this.x, this.y);\n\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => this.x(d.x))\n      .y((d) => this.y(d.y));\n\n    this.paths\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"stroke\", ([z]) => this.colors(z))\n      .attr(\"class\", ([z]) => className(z))\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n\n    this.update(this.x, this.y);\n  }\n\n  getDashArray(z, i, lengths, previousUpdate) {\n    // By default, the dasharray performs an opening animation\n    if (z in this.patterns) {\n      // Custom patterns can be specified with setPattern()\n      const p = this.patterns[z];\n      if (previousUpdate) return p.join(\" \");\n      return lengths[i] ? animatedDashArray(p, lengths[i]) : null;\n    }\n    if (previousUpdate) return \"1 0\";\n    return lengths[i] ? `${lengths[i]} ${lengths[i]}` : null;\n  }\n\n  getDashOffset(z, i, lengths) {\n    // TODO Option to reverse opening? Set to -length?\n    return animatedDashOffset(this.patterns[z], lengths[i]);\n  }\n\n  update(x, y) {\n    this.hideDot();\n\n    const isEmpty = this.empty;\n\n    // Option to hide the chart if there's no visible data\n    if (this.config.HIDE_EMPTY_CHART) {\n      this.svg\n        .transition()\n        .duration(this.config.DURATION_MS)\n        .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n    }\n\n    // Re-draw the chart with the new x and y scales\n    // NOTE: with current setup, x-axis doesn't need to be updated\n    this.gx\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(this.xAxis.bind(this), x);\n\n    this.gy\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(this.yAxis.bind(this), y)\n      .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n\n    // Grid lines have a hardcoded opacity 1, so we need to use visibility to hide them\n    this.gGrid\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"visibility\", isEmpty ? \"hidden\" : \"visible\")\n      .call(this.grid.bind(this), x, y);\n\n    // Plot the line\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => x(d.x))\n      .y((d) => y(d.y));\n\n    // If paths were previously updated, remove the offset and set simple patterns\n    if (this.previousUpdate) {\n      this.paths\n        .attr(\"stroke-dasharray\", ([z]) => this.getDashArrayAttr(z))\n        .attr(\"stroke-dashoffset\", null);\n    }\n\n    const transition = this.paths\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n\n    if (!this.previousUpdate) {\n      // Initial opening animation\n      const lengths = d3.map(this.paths, (elem) => getLength(elem));\n\n      this.paths.attr(\"stroke-dasharray\", ([z], i) =>\n        this.getDashArray(z, i, lengths),\n      );\n\n      transition.attrTween(\"stroke-dashoffset\", ([z], i) =>\n        this.getDashOffset(z, i, lengths),\n      );\n    }\n    this.previousUpdate = true;\n  }\n\n  placeDot(index) {\n    // Place a dot at the given index\n    const d = this.data[index];\n    this.dot\n      .style(\"display\", null)\n      .attr(\"transform\", `translate(${this.x(d.x)},${this.y(d.y)})`);\n    this.circle.attr(\"fill\", this.colors(d.z));\n  }\n\n  hideDot() {\n    this.dot.style(\"display\", \"none\");\n  }\n\n  noHighlight() {\n    // Reset all lines to default\n    this.paths\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0))\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH);\n  }\n\n  highlight(z) {\n    // Hide paths that aren't the currently selected path\n    this.paths\n      .attr(\"opacity\", ([elem]) => {\n        if (this.hidden.has(elem)) return 0;\n        return elem === z ? 1.0 : this.config.BACKGROUND_OPACITY;\n      })\n      .attr(\"stroke-width\", ([elem]) =>\n        elem === z\n          ? this.config.HIGHLIGHT_STROKE_WIDTH\n          : this.config.STROKE_WIDTH,\n      );\n  }\n\n  onEvent(move, leave) {\n    // let prevIndex = null;\n\n    const pointermove = (evt) => {\n      if (evt.touches) {\n        // Prevent scroll on touch devices\n        evt.preventDefault();\n        evt = evt.touches[0];\n      }\n\n      // X and y scales use the inner element, which is padded\n      let [xm, ym] = d3.pointer(evt, this.gInner.node());\n\n      // Determine the closest point to the cursor\n      // TODO Points could be memoized based on hidden z items\n      const points = d3.map(this.data, (d) => {\n        if (this.hidden.has(d.z)) return null;\n        return Math.hypot(this.x(d.x) - xm, this.y(d.y) - ym);\n      });\n\n      const index = d3.leastIndex(points);\n      if (index === -1 || points[index] === null) return;\n\n      // Exit early if no point was found\n      if (typeof index === \"undefined\") return;\n\n      // TODO To only trigger the callback when the index changes\n      // if (prevIndex && prevIndex == index) return;\n\n      this.placeDot(index);\n\n      const d = this.data[index];\n\n      // Data that will be provided to the callback: include both the coordinates\n      // of the dot and the pointer, both in relation to the page\n      const [dx, dy] = pageXY(this.dot.node());\n      const [px, py] = d3.pointer(evt, null);\n\n      const data = {\n        x: d.x,\n        y: d.y,\n        z: d.z,\n        // Dot page coordinates\n        dx: dx,\n        dy: dy,\n        // Pointer page coordinates\n        px: px,\n        py: py,\n      };\n\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      this.hideDot();\n      if (leave) {\n        leave.call(this, evt);\n      }\n    };\n\n    // Separate mouse and touch events\n    this.svg\n      .on(\"mousemove\", throttle(pointermove, 1000.0 / this.config.FPS))\n      .on(\"mouseleave\", pointerleave)\n      .on(\"touchstart\", pointermove, { passive: false })\n      .on(\"touchmove\", throttle(pointermove, 1000.0 / this.config.FPS), {\n        passive: false,\n      })\n      .on(\"touchend\", pointerleave, { passive: false });\n  }\n\n  toggle() {\n    if (this.visibleData.length) {\n      // Recalculate the y-scale based on the non-hidden items\n      this.y = this.yScale;\n    } else {\n      // Set y-axis to zero\n      // We would need the last y-axis domain in order to prevent tick labels\n      // from changing during this transition\n      this.y = d3\n        .scaleLinear()\n        .domain(this.y.domain())\n        .range([this.layout.innerHeight, this.layout.innerHeight]);\n    }\n    this.update(this.x, this.y);\n  }\n}\n\nexport function Line(data, parser) {\n  return new LineChart(data, parser);\n}\n\nexport class TimeSeriesChart extends LineChart {\n  get xScale() {\n    // Never re-calculate the x-axis\n    return d3\n      .scaleUtc()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  sortData(data) {\n    data.sort((a, b) => a.x - b.x);\n    return data;\n  }\n\n  parseData(data, parser) {\n    // Sort timeseries data in ascending order\n    return this.sortData(super.parseData(data, parser));\n  }\n}\n\nexport function TimeSeries(data, parser) {\n  return new TimeSeriesChart(data, parser);\n}\n", "/*\nAnimation helper functions.\n*/\n\nimport * as d3 from \"d3\";\n\nexport function animatedDashArray(pattern, totalLength) {\n  pattern = pattern || [];\n  // Returns the stroke-dasharray string that can be used to animate a dashed line\n  // Pattern should be an array of integers, with an empty array being a solid line\n  if (!pattern.length) return `${totalLength} ${totalLength}`;\n\n  if (pattern.length % 2) {\n    pattern = pattern.concat(pattern);\n  }\n\n  const dash = pattern.join(\" \"); // The pattern that will be repeated as a string\n  const dashLength = d3.sum(pattern);\n  if (!dashLength) return `${totalLength} ${totalLength}`;\n  const count = Math.ceil(totalLength / dashLength);\n  const repeated = new Array(count).fill(dash).join(\" \");\n\n  // After the repeated portion, show an empty section the length of the line\n  // This empty section will give the appearance of opening as its offset is changed\n  return `${repeated} 0 ${Math.ceil(totalLength)}`;\n}\n\nexport function animatedDashOffset(pattern, totalLength) {\n  // Returns the stroke-dashoffset string that can be used to animate a dashed line\n  pattern = pattern || [];\n\n  if (pattern.length % 2) {\n    pattern = pattern.concat(pattern);\n  }\n\n  const dashLength = d3.sum(pattern);\n  if (dashLength) {\n    return (t) => Math.round(((1 - t) * totalLength) / dashLength) * dashLength;\n  }\n  return d3.interpolate(totalLength, 0);\n}\n\nexport function updatePattern(pattern, ratio) {\n  return d3.map(pattern, (d) => d * ratio);\n}\n", "import * as d3 from \"d3\";\n\nimport { quantizeScheme } from \"./colors\";\n\nexport class Chart {\n  // Base class for charts\n  // Currently only has some common chained config methods for layout and animation\n\n  constructor(data, parser = (d) => d) {}\n\n  /* Config chained methods */\n  screenHeightPercent(value) {\n    this.config.LAYOUT.screenHeightPercent = value;\n    return this;\n  }\n\n  minHeight(value) {\n    this.config.LAYOUT.minHeight = value;\n    return this;\n  }\n\n  maxHeight(value) {\n    this.config.LAYOUT.maxHeight = value;\n    return this;\n  }\n\n  height(value) {\n    return this.minHeight(value).maxHeight(value);\n  }\n\n  minWidth(value) {\n    this.config.LAYOUT.minWidth = value;\n    return this;\n  }\n\n  maxWidth(value) {\n    this.config.LAYOUT.maxWidth = value;\n    return this;\n  }\n\n  width(value) {\n    return this.minWidth(value).maxWidth(value);\n  }\n\n  animationDuration(value) {\n    this.config.DURATION_MS = value;\n    return this;\n  }\n\n  noAnimation() {\n    return this.animationDuration(0);\n  }\n\n  node() {\n    // Return the chart svg node. Return null if the chart hasn't been rendered.\n    return this.svg ? this.svg.node() : null;\n  }\n}\n\nexport class CategoricalChart extends Chart {\n  // Adds additional chained config methods for schemes and hidden state\n\n  constructor(data, parser = (d) => d) {\n    // Items can be dynamically hidden from the chart\n    super(data, parser);\n    this.hidden = new d3.InternSet();\n  }\n\n  /* Chained config methods */\n  backgroundOpacity(value) {\n    this.config.BACKGROUND_OPACITY = value;\n    return this;\n  }\n\n  yAxisRight() {\n    // The y axis ticks and labels will be shown on the right of the chart\n    this.config.Y_AXIS_RIGHT = true;\n    return this;\n  }\n\n  useDiscreteScheme(scheme) {\n    this.colors = d3.scaleOrdinal().domain(this.Z).range(scheme);\n    return this;\n  }\n\n  useContinuousScheme(scheme, min = 0.0, max = 1.0) {\n    return this.useDiscreteScheme(\n      quantizeScheme(this.Z.length, scheme, min, max),\n    );\n  }\n\n  invertScheme() {\n    this.colors = this.colors.range(this.colors.range().reverse());\n    return this;\n  }\n\n  startHidden() {\n    // The first render will have all items hidden\n    this.hidden = new d3.InternSet(this.Z);\n    return this;\n  }\n  /* End chained config methods */\n\n  hide(...z) {\n    // Add the given z elements to the hidden set\n    this.hidden = this.hidden.union(new d3.InternSet(z));\n    this.toggle();\n  }\n\n  show(...z) {\n    // Remove the given z elements from the hidden set\n    this.hidden = this.hidden.difference(new d3.InternSet(z));\n    this.toggle();\n  }\n\n  setHidden(...z) {\n    this.hidden = new d3.InternSet(z);\n  }\n\n  hideAll() {\n    this.hidden = new d3.InternSet(this.Z);\n    this.toggle();\n  }\n\n  showAll() {\n    this.hidden.clear();\n    this.toggle();\n  }\n\n  showOnly(...z) {\n    // Show only the given z elements, all others will be hidden\n    this.hidden = new d3.InternSet(this.Z).difference(new d3.InternSet(z));\n    this.toggle();\n  }\n}\n", "import * as d3 from \"d3\";\n\nexport function quantizeScheme(n, scheme, min = 0.0, max = 1.0) {\n  if (n === 1) {\n    // If there is only one item, just use the middle of the scheme\n    return [scheme((max - min) / 2.0 + min)];\n  }\n  return d3.quantize((t) => scheme(t * (max - min) + min), n);\n}\n", "import * as d3 from \"d3\";\n\n/*\nMost of the layout operations are placing a rectangle within another rectangle.\nWhat is the most generic way to do this?\n*/\n\nexport class Pad {\n  constructor(top, right, bottom, left) {\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n}\n\nexport function EqualPad(value) {\n  return new Pad(value, value, value, value);\n}\n\nexport function DefaultPad() {\n  return new Pad(15, 15, 25, 25);\n}\n\nexport class Layout {\n  constructor(width, height, pad) {\n    this.width = width;\n    this.height = height;\n    this.pad = pad || DefaultPad();\n  }\n\n  get rangeX() {\n    return [this.pad.left, this.width - this.pad.right];\n  }\n\n  get rangeY() {\n    return [this.height - this.pad.bottom, this.pad.top];\n  }\n\n  get innerWidth() {\n    return this.width - this.pad.left - this.pad.right;\n  }\n\n  get innerHeight() {\n    return this.height - this.pad.top - this.pad.bottom;\n  }\n\n  get innerMinimum() {\n    return d3.min([this.innerWidth, this.innerHeight]);\n  }\n\n  get midpoint() {\n    return [this.width / 2, this.height / 2];\n  }\n}\n\nexport function getLayout(\n  elem,\n  {\n    minWidth = 400,\n    maxWidth = undefined,\n    minHeight = 300,\n    maxHeight = undefined,\n    screenHeightPercent = 0.5,\n  } = {},\n) {\n  const chart = document.querySelector(elem);\n  let width = d3.max([chart.offsetWidth, minWidth]);\n  if (maxWidth) {\n    width = d3.min([width, maxWidth]);\n  }\n\n  let height = window.innerHeight * screenHeightPercent;\n  height = d3.max([height, minHeight]);\n  if (maxHeight) {\n    height = d3.min([height, maxHeight]);\n  }\n  return new Layout(width, height, DefaultPad());\n}\n\nexport function maxTickWidth(defaults, height, domain, format, options) {\n  // Create a fake axis to test label tick size\n  const hidden = d3\n    .select(\"body\")\n    .append(\"svg\")\n    .attr(\"width\", 100)\n    .attr(\"height\", height)\n    .style(\"visibility\", \"hidden\"); // \"display: none\" does not work\n\n  let scale = d3\n    .scaleLinear()\n    .domain(domain)\n    .range([height - defaults.bottom, defaults.top]);\n\n  let axis = d3\n    .axisLeft(scale)\n    .tickFormat(format) // Can be null\n    .tickSize(0)\n    .ticks(8); // TODO Number of ticks as an option\n\n  const g = hidden.append(\"g\").style(\"font-size\", options.FONT_SIZE).call(axis);\n\n  // Measure the tick labels\n  const labels = g.selectAll(\".tick text\");\n\n  let width = 0;\n  labels.each(function () {\n    const bbox = this.getBoundingClientRect(); // TODO Or getBBox?\n    if (bbox.width > width) {\n      width = bbox.width;\n    }\n  });\n\n  // Remove the axis\n  hidden.remove();\n\n  // Pad\n  return width + options.X_TICK_GUTTER + 5;\n}\n\nexport function appendSVG(selector, width, height) {\n  // Append an SVG element to the selected element\n  return d3\n    .select(selector)\n    .append(\"svg\")\n    .attr(\"viewBox\", `0 0 ${width} ${height}`)\n    .attr(\"style\", \"max-width: 100%; height: intrinsic;\")\n    .style(\"-webkit-tap-highlight-color\", \"transparent\")\n    .style(\"overflow\", \"visible\");\n}\n\nexport function layoutSVG(selector, options) {\n  // Return the SVG elements and its layout\n  // Available options:\n  // * screenHeightPercent\n  // * minWidth\n  // * maxWidth\n  // * minHeight\n  // * maxHeight\n  const elem = d3.select(selector);\n  if (!elem.node()) {\n    throw new Error(`Unable to find a DOM element for selector '${selector}'`);\n  }\n\n  if (elem.node().tagName === \"svg\") {\n    const svg = elem;\n    const width = +svg.attr(\"width\");\n    const height = +svg.attr(\"height\");\n    // TODO Fallback to viewbox\n    if (width && height) {\n      return [svg, new Layout(width, height)];\n    } else {\n      // TODO SVGs must have a width or height or the defaults will be returned\n      const layout = getLayout(selector, options);\n      return [svg, layout];\n    }\n  }\n\n  const layout = getLayout(selector, options);\n  const svg = appendSVG(selector, layout.width, layout.height);\n  return [svg, layout];\n}\n", "import * as d3 from \"d3\";\n\nexport function parseArrayOHLCV(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    o: d[1],\n    h: d[2],\n    l: d[3],\n    c: d[4],\n    v: d[5],\n  };\n}\n\nexport function parseVerboseOHLCV(d) {\n  return {\n    x: d3.isoParse(d.date),\n    o: d.open,\n    h: d.high,\n    l: d.low,\n    c: d.close,\n    v: d.volume,\n  };\n}\n\nexport function parse3dArray(d) {\n  return {\n    x: d[0],\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport function parseTimeSeries3dArray(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport function parseTimeSeries2dArray(d) {\n  // No z axis\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[1],\n    z: \"\",\n  };\n}\n\nexport function parseArrayYZ(d) {\n  // For data without an x-axis\n  return {\n    x: null,\n    y: d[0],\n    z: d[1],\n  };\n}\n", "const invalidChars = /[^a-zA-Z0-9_-]/g;\nconst invalidStart = /^[^a-zA-Z_]/;\n\nexport function className(value) {\n  // Sanitize the given string so it can be used as a class name\n  // Spaces will be replaced with underscores, other invalid characters will be removed\n  value = String(value).trim().replaceAll(\" \", \"_\").replace(invalidChars, \"\");\n\n  // Prepend an underscore if the name starts will an invalid character\n  if (invalidStart.test(value)) {\n    value = \"_\" + value;\n  }\n  return value;\n}\n", "export function throttle(fn, timeout) {\n  var free = true;\n  return function () {\n    if (free) {\n      fn.apply(this, arguments);\n      free = false;\n      setTimeout(() => {\n        free = true;\n      }, timeout);\n    }\n  };\n}\n", "import * as d3 from \"d3\";\n\nexport function maxLabelSize(svg, layout, scale, format = null, cls = \"\") {\n  // Create a fake axis to test label tick size\n  // Does not include the tick size or padding, is just the label width\n  // This access should be part of the current chart's selection and have the same\n  // class values in order to correctly match any CSS that changes label sizes\n  const hidden = svg\n    .append(\"g\")\n    .attr(\"width\", layout.innerWidth)\n    .attr(\"height\", layout.innerHeight)\n    .attr(\"class\", cls)\n    .style(\"visibility\", \"hidden\"); // \"display: none\" does not work\n\n  const axis = d3.axisLeft(scale).tickFormat(format); // Can be null\n  const g = hidden.call(axis);\n\n  // Measure the tick labels\n  const labels = g.selectAll(\".tick text\");\n\n  let width = 0;\n  let height = 0;\n  labels.each(function () {\n    const elem = this.getBoundingClientRect(); // TODO Or getBBox?\n    if (elem.width > width) {\n      width = elem.width;\n    }\n    if (elem.height > height) {\n      height = elem.height;\n    }\n  });\n\n  hidden.remove();\n  return [width, height];\n}\n\n/*\nIn order to filter categorical ticks, we need:\n1. the width of the largest tick label\n2. the total available width for the axes in the layout\n3. the interval that will fit that largest label without overlap\n4. then filter the available tick labels by the interval\nAn optional offset can be provided, which will skip the ticks with a lower index\n*/\nexport function filterTicks(ticks, layout, labelWidth, offset = 0) {\n  const count = parseInt(layout.innerWidth / (labelWidth + 1)) + 1;\n  const interval = d3.max([parseInt(Math.ceil(ticks.length / count)), 1]);\n  return d3.filter(\n    ticks,\n    (d, i) => i - offset >= 0 && (i - offset) % interval === 0,\n  );\n}\n\n// Another variant of filterTicks that automatically determines an offset\nexport function filterTicksAutoOffset(ticks, layout, labelWidth) {\n  const count = parseInt(layout.innerWidth / (labelWidth + 1)) + 1;\n  const interval = d3.max([parseInt(Math.ceil(ticks.length / count)), 1]);\n  const offset = interval > 1 ? Math.floor(interval / 2) : 0;\n  return d3.filter(\n    ticks,\n    (d, i) => i - offset >= 0 && (i - offset) % interval === 0,\n  );\n}\n\nexport function invertBand(scale, x) {\n  const domain = scale.domain();\n  const index = Math.floor((x - scale(domain[0])) / scale.step());\n  return Math.max(0, Math.min(index, domain.length - 1));\n}\n\nexport function zoomRange(domain, width, start, end) {\n  // Return the range extent needed to zoom to the start and end indices of the domain\n  let w = end - start + 1;\n  let ratio = 1;\n  if (w < domain.length) {\n    ratio = domain.length / w;\n  }\n  const zoomWidth = width * ratio;\n  const offsetX = (start / domain.length) * zoomWidth;\n  return [0 - offsetX, zoomWidth - offsetX];\n}\n", "export function placeTooltip(container, tooltip, dx, dy, padding = 5) {\n  // Returns x and y page coordinates and text-align that will optimally place the\n  // tooltip in the container. The container and tooltip must be DOM elements with\n  // offset properties. The dx and dy should be page x and y of the event.\n  const bbox = container.getBoundingClientRect();\n  const px = dx - bbox.left - window.scrollX;\n  const py = dy - bbox.top - window.scrollY;\n\n  let x = padding;\n  let y = -tooltip.offsetHeight - padding;\n  let align = \"left\";\n\n  // TODO Limit to half the container?\n  if (px > bbox.width - tooltip.offsetWidth - padding) {\n    // Right side of container\n    x = -tooltip.offsetWidth - padding;\n    align = \"right\";\n  }\n\n  if (py < tooltip.offsetHeight + padding) {\n    // Top of the container\n    y = padding;\n  }\n\n  return [dx + x, dy + y, align];\n}\n\nexport function placeTooltipTop(container, tooltip, dx, dy, padding = 5) {\n  // Similar to placeTooltip, but always places the tooltip above the dx, dy\n  const bbox = container.getBoundingClientRect();\n  const px = dx - bbox.left - window.scrollX;\n\n  let x = padding;\n  let y = -tooltip.offsetHeight - padding;\n  let align = \"left\";\n\n  // TODO Limit to half the container?\n  if (px > bbox.width - tooltip.offsetWidth - padding) {\n    // Right side of container\n    x = -tooltip.offsetWidth - padding;\n    align = \"right\";\n  }\n\n  return [dx + x, dy + y, align];\n}\n\nexport function pageXY(node) {\n  // Get the page x and y of the given node\n  const svg = node.ownerSVGElement || node;\n  if (svg.createSVGPoint) {\n    let point = svg.createSVGPoint();\n    point = point.matrixTransform(node.getScreenCTM());\n    return [point.x + +window.scrollX, point.y + +window.scrollY];\n  }\n  if (node.getBoundingClientRect) {\n    // Calculate the page coordinates by adding the scroll offsets\n    const rect = node.getBoundingClientRect();\n    return [rect.left + window.scrollX, rect.top + window.scrollY];\n  }\n  return [undefined, undefined];\n}\n"],
  "mappings": "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",
  "names": ["require_d3", "__commonJSMin", "exports", "module", "line_exports", "__export", "Line", "LineChart", "TimeSeries", "TimeSeriesChart", "parse3dArray", "parseTimeSeries3dArray", "placeTooltip", "placeTooltipTop", "d3", "d3", "animatedDashArray", "pattern", "totalLength", "dash", "dashLength", "count", "animatedDashOffset", "t", "d3", "d3", "quantizeScheme", "n", "scheme", "min", "max", "t", "Chart", "data", "parser", "d", "value", "CategoricalChart", "scheme", "min", "max", "quantizeScheme", "z", "d3", "Pad", "top", "right", "bottom", "left", "DefaultPad", "Pad", "Layout", "width", "height", "pad", "getLayout", "elem", "minWidth", "maxWidth", "minHeight", "maxHeight", "screenHeightPercent", "chart", "appendSVG", "selector", "width", "height", "layoutSVG", "options", "elem", "svg", "Layout", "layout", "getLayout", "d3", "parse3dArray", "d", "parseTimeSeries3dArray", "invalidChars", "invalidStart", "className", "value", "throttle", "fn", "timeout", "free", "d3", "maxLabelSize", "svg", "layout", "scale", "format", "cls", "hidden", "axis", "labels", "width", "height", "elem", "placeTooltip", "container", "tooltip", "dx", "dy", "padding", "bbox", "px", "py", "x", "y", "align", "placeTooltipTop", "pageXY", "node", "svg", "point", "rect", "uniqueID", "getLength", "elem", "LineChart", "CategoricalChart", "data", "parser", "d", "__publicField", "z", "pattern", "visible", "i", "g", "x", "y", "xLabelWidth", "xLabelHeight", "maxLabelSize", "yLabelWidth", "yLabelHeight", "selector", "clipPathID", "layoutSVG", "yTransform", "grouping", "isEmpty", "line", "I", "className", "lengths", "previousUpdate", "p", "animatedDashArray", "animatedDashOffset", "transition", "index", "move", "leave", "pointermove", "evt", "xm", "ym", "points", "dx", "dy", "pageXY", "px", "py", "pointerleave", "throttle", "Line", "TimeSeriesChart", "a", "b", "TimeSeries"]
}
