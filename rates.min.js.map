{
  "version": 3,
  "sources": ["external-global-plugin:d3", "rates.js", "../node_modules/@aodin/charts/src/area.js", "../node_modules/@aodin/charts/src/chart.js", "../node_modules/@aodin/charts/src/options.js", "../node_modules/@aodin/charts/src/layout.js", "../node_modules/@aodin/charts/src/bar.js", "../node_modules/@aodin/charts/src/timeseries.js", "../node_modules/@aodin/charts/src/colors.js", "../node_modules/@aodin/charts/src/formats.js", "../node_modules/@aodin/charts/src/line.js", "../node_modules/@aodin/charts/src/throttle.js", "../node_modules/@aodin/charts/src/ohlcv.js"],
  "sourcesContent": ["module.exports = d3", "/*\nExample exchange rate chart that extends a line chart\n*/\nimport { Line, maxTickWidth, discreteColorMap, getDimensions } from \"@aodin/charts\";\n\nconst percentChange = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n  signDisplay: \"exceptZero\",\n});\n\n// TODO Can replace with Quarter on next version bump\nfunction Q(d) {\n  // Format a Date as a quarter and year\n  const q = parseInt(d.getUTCMonth() / 3) + 1;\n  return `${q}Q ${d.getUTCFullYear()}`;\n}\n\nexport class Rates extends Line {\n  tickFormatY = d3.format(\",.1%\");\n  tickFormatX = (v, i) => v.getUTCFullYear();\n\n  getDimensions(elem) {\n    // TODO Alter the ratio if the screen is in portrait or landscape?\n    const chart = document.querySelector(elem)\n    return [chart.offsetWidth, window.innerHeight * 0.7]\n  }\n\n  getMargin(width, height) {\n    const margin = {\n      top: 15,\n      right: 15,\n      bottom: 15,\n      left: 15,\n    };\n\n    margin.left = maxTickWidth(\n      margin,\n      height,\n      this.getDomainY(),\n      this.tickFormatY,\n      this.options,\n    )\n\n    return margin;\n  }\n\n  getTickValuesX() {\n    // Show a tick on the Q1 of every year, instead of Jan 1st\n    const [start, end] = this.getDomainX();\n    const years = d3.range(\n      start.getUTCFullYear() + 1,\n      end.getUTCFullYear() + 1,\n    );\n    return d3.map(years, (year) => new Date(year, 2, 31));\n  }\n\n  parse(data, hide) {\n    // Parse data object, determine:\n    // * x, y, z values as desired types\n    // * items lookup by any property\n    // * color mapping (discrete / scale)\n    // Is defined lookup\n    // grouping? for tooltips?\n    let values = data.values;\n    if (hide && hide.size > 0) {\n      // Remove the items from the values before parsing\n      values = data.values.filter((item) => !hide.has(item[1]));\n    }\n\n    // TODO This data parse is specific to line series data\n    this.X = d3.map(values, (d) => d3.isoParse(d[0]));\n    this.Y = d3.map(values, (d) => d[2]);\n    this.Z = d3.map(values, (d) => d[1]);\n\n    // Items stores additional info on Z axis keys\n    this.items = data.items;\n\n    // The items use abbrev as a key\n    this.byKey = Object.fromEntries(this.items.map((obj) => [obj.abbrev, obj]));\n\n    // Defined?\n    // TODO This doesn't work for missing values\n    const defined = (d, i) => !isNaN(this.X[i]) && !isNaN(this.Y[i]);\n    this.D = d3.map(values, defined);\n\n    // grouping\n    this.I = d3.range(this.X.length);\n    this.grouping = d3.group(this.I, (i) => this.Z[i]); // {name: [indexes...]}\n\n    // Colors\n    // TODO discrete v continuous?\n    this.setColors(data);\n  }\n\n  hide(items, elem) {\n    this.clear();\n    this.parse(this.data, new Set(items));\n    this.render(elem);\n  }\n\n  setColors(data) {\n    const abbrevs = d3.map(this.items, (d) => d.abbrev);\n    const colors = discreteColorMap(abbrevs, d3.interpolateRainbow);\n    this.colors = d3.scaleOrdinal().domain(abbrevs).range(colors);\n  }\n\n  formatX(value) {\n    // Function for formatting X values, called before sending to hover data callbacks\n    return Q(value);\n  }\n\n  formatY(value) {\n    // Function for formatting Y values, called before sending to hover data callbacks\n    return percentChange.format(value);\n  }\n\n  formatZ(key) {\n    // Function for formatting Z values, called before sending to hover data callbacks\n    return this.byKey[key].name;\n  }\n\n  getLegend() {\n    // Return the z items along with their colors\n    return d3.map(this.items, (d) => {\n      return Object.assign({ color: this.getColor(d.abbrev) }, d);\n    });\n  }\n}\n", "/*\nArea chart\n*/\nimport * as d3 from \"d3\";\n\nimport { Chart } from \"./chart\";\n\nexport class Area extends Chart {\n  parse(data) {\n    // Get distinct items from the list of Z values\n    this.Z = this.parseZ(data);\n    this.items = new Set(this.Z);\n\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d3.isoParse(d[0]),\n      (d) => d[2],\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    this.stack = d3\n      .stack()\n      .keys(this.items)\n      .value(([, group], key) => {\n        let item = group.get(key);\n        return item ? item[1] : 0;\n      })(indexed);\n\n    // Use the stack to determine the x and y-axis domains\n    this.X = [...indexed.keys()];\n    this.Y = [0, d3.max(this.stack[this.stack.length - 1], (d) => d[1])];\n\n    this.setColors(data);\n  }\n\n  getDomainX() {\n    return d3.extent(this.X);\n  }\n\n  getDomainY() {\n    return this.Y;\n  }\n\n  render(elem) {\n    // Determine the size of the DOM element\n    const [width, height] = this.getDimensions(elem);\n    const dimensions = { width, height };\n    const margin = this.getMargin(width, height);\n\n    this.createSVG(elem, dimensions);\n\n    // Y-axis\n    const yScale = d3\n      .scaleLinear()\n      .domain(this.getDomainY())\n      .range(this.getRangeY(dimensions, margin));\n\n    let yAxis = d3\n      .axisLeft(yScale)\n      .tickValues(this.getTickValuesY())\n      .tickFormat(this.tickFormatY)\n      .tickSize(0)\n      .ticks(8);\n\n    // X-axis\n    const xScale = d3\n      .scaleUtc()\n      .domain(this.getDomainX())\n      .range(this.getRangeX(dimensions, margin));\n\n    let xAxis = d3\n      .axisBottom(xScale)\n      .tickValues(this.getTickValuesX())\n      .tickFormat(this.tickFormatX)\n      .tickSizeInner(this.options.X_TICK_SIZE);\n\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(0,${dimensions.height - margin.bottom + this.options.X_TICK_GUTTER})`,\n      )\n      .call(xAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(${margin.left - this.options.Y_TICK_GUTTER},0)`,\n      )\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove())\n      .call((g) =>\n        g\n          .selectAll(\".tick line\")\n          .clone()\n          .attr(\"stroke\", \"#888\") // Works for black or white background at 40% opacity\n          .attr(\"stroke-opacity\", 0.4)\n          .attr(\"x1\", this.options.Y_TICK_GUTTER)\n          .attr(\n            \"x2\",\n            dimensions.width -\n              margin.right -\n              margin.left +\n              this.options.Y_TICK_GUTTER,\n          ),\n      );\n\n    // Construct an area\n    const area = d3\n      .area()\n      .x((d) => xScale(d.data[0]))\n      .y0((d) => yScale(d[0]))\n      .y1((d) => yScale(d[1]));\n\n    // Append a path for each series.\n    this.svg\n      .append(\"g\")\n      .selectAll()\n      .data(this.stack)\n      .join(\"path\")\n      .attr(\"fill\", (d) => this.getColor(d.key))\n      .attr(\"d\", area);\n  }\n}\n", "import * as d3 from \"d3\";\n\nimport { Options } from \"./options\";\nimport { getDimensions } from \"./layout\";\n\nexport class Chart {\n  // By default, tick format functions are null, which will use the default D3\n  // functions. These can be overridden by sub-classes\n  tickFormatX = null;\n  tickFormatY = null;\n\n  constructor(data, options = {}) {\n    this.options = new Options(options);\n    this.data = data; // Save the original data in case we want to recalculate\n    this.parse(data);\n  }\n\n  getMargin(width, height) {\n    return {\n      top: 15,\n      right: 15,\n      bottom: 25,\n      left: 45,\n    };\n  }\n\n  getTickValuesX() {\n    // D3.js will use the default tick values if null is used\n    return null;\n  }\n\n  getTickValuesY() {\n    // D3.js will use the default tick values if null is used\n    return null;\n  }\n\n  parse(data) {\n    // This data parse is specific to line series data\n    this.X = this.parseX(data);\n    this.Y = this.parseY(data);\n    this.Z = this.parseZ(data);\n\n    // Get distinct items from the set of Z values\n    this.items = new Set(this.Z);\n\n    // Is defined?\n    // TODO This doesn't work for missing values, only null or undefined\n    const defined = (d, i) => !isNaN(this.X[i]) && !isNaN(this.Y[i]);\n    this.D = d3.map(data, defined);\n\n    // Grouping\n    this.I = d3.range(this.X.length);\n    this.grouping = d3.group(this.I, (i) => this.Z[i]); // {name: [indexes...]}\n\n    // Colors\n    this.setColors(data);\n  }\n\n  formatX(value) {\n    // Function for formatting X values, called before sending to hover data callbacks\n    return value;\n  }\n\n  formatY(value) {\n    // Function for formatting Y values, called before sending to hover data callbacks\n    return value;\n  }\n\n  formatZ(key) {\n    // Function for formatting Z values, called before sending to hover data callbacks\n    return key;\n  }\n\n  parseX(data) {\n    return d3.map(data, (d) => d3.isoParse(d[0]));\n  }\n\n  parseY(data) {\n    return d3.map(data, (d) => d[1]);\n  }\n\n  parseZ(data) {\n    return d3.map(data, (d) => d[2]);\n  }\n\n  getDomainX() {\n    return d3.extent(this.X);\n  }\n\n  getRangeX(dimensions, margin) {\n    return [margin.left, dimensions.width - margin.right];\n  }\n\n  getDomainY() {\n    return d3.extent(this.Y);\n  }\n\n  getRangeY(dimensions, margin) {\n    return [dimensions.height - margin.bottom, margin.top];\n  }\n\n  setColors(data) {\n    this.colors = d3\n      .scaleOrdinal()\n      .domain(this.items)\n      .range(this.options.COLORS);\n  }\n\n  getColor(z) {\n    return this.colors(z);\n  }\n\n  getDimensions(elem) {\n    // Given the chart's DOM element, return the desired width and height for drawing\n    return getDimensions(elem, { ratio: 0.35 });\n  }\n\n  createSVG(elem, dimensions) {\n    // Clear any existing chart\n    d3.select(elem).selectAll(\"svg\").remove();\n\n    // Create a new chart\n    this.svg = d3\n      .select(elem)\n      .append(\"svg\")\n      .attr(\"viewBox\", [0, 0, dimensions.width, dimensions.height])\n      .attr(\"style\", \"max-width: 100%; height: intrinsic;\")\n      .style(\"-webkit-tap-highlight-color\", \"transparent\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .style(\"overflow\", \"visible\");\n  }\n\n  clear() {\n    // Clear all drawn elements, must have an element set\n    if (this.svg) this.svg.selectAll(\"*\").remove();\n  }\n}\n", "import * as d3 from \"d3\";\n\nexport class Options {\n  constructor(options = {}) {\n    this.ANIMATION_DURATION_MS = 500;\n    // TODO Allow either number of x-ticks OR minimum x tick spacing\n    this.X_TICK_SIZE = 4;\n    this.X_TICK_GUTTER = 3;\n    this.Y_TICK_SIZE = 0;\n    this.Y_TICK_GUTTER = 5; // Space between tick label and grid\n    this.FONT_SIZE = \"13px\";\n    this.COLORS = d3.schemeCategory10;\n\n    // OHLC\n    this.BAND_PADDING = 0.2; // As a percentage of the band\n    this.VOLUME_OPACITY = 0.6;\n    this.OHLC_COLORS = [\"#1ebc8c\", \"#b2b2b2\", \"#f34d27\"]; // [up, no change, down]\n\n    // Line\n    this.STROKE_WIDTH = 1.5;\n    this.HIGHLIGHT_STROKE_WIDTH = 2.0;\n    this.BACKGROUND_OPACITY = 0.3; // When another line is highlighted\n    this.DOT_RADIUS = 3.0;\n\n    // Bar\n    this.BAR_STROKE_WIDTH = 0.0;\n\n    // TODO POINTER MOVE FPS\n    this.EVENT_FPS = 48;\n\n    // Allow user to override any of the above defaults\n    Object.assign(this, options);\n  }\n\n  get eventLatency() {\n    return parseInt(1000 / this.EVENT_FPS);\n  }\n}\n", "import * as d3 from \"d3\";\n\nexport function getDimensions(\n  elem,\n  { ratio = 0.2, maxWidth = 1600, minWidth = 400, minHeight = 300 } = {},\n) {\n  const chart = document.querySelector(elem);\n  let width = d3.min([chart.offsetWidth, maxWidth]);\n  width = d3.max([chart.offsetWidth, minWidth]);\n  let height = d3.max([parseInt(ratio * width), minHeight]);\n  return [width, height];\n}\n\nexport function maxTickWidth(defaults, height, domain, format, options) {\n  // Create a fake axis to test label tick size\n  const hidden = d3\n    .select(\"body\")\n    .append(\"svg\")\n    .attr(\"width\", 100)\n    .attr(\"height\", height)\n    .style(\"visibility\", \"hidden\"); // \"display: none\" does not work\n\n  let scale = d3\n    .scaleLinear()\n    .domain(domain)\n    .range([height - defaults.bottom, defaults.top]);\n\n  let axis = d3\n    .axisLeft(scale)\n    .tickFormat(format) // Can be null\n    .tickSize(0)\n    .ticks(8); // TODO Number of ticks as an option\n\n  const g = hidden.append(\"g\").style(\"font-size\", options.FONT_SIZE).call(axis);\n\n  // Measure the tick labels\n  const labels = g.selectAll(\".tick text\");\n\n  let width = 0;\n  labels.each(function () {\n    const bbox = this.getBoundingClientRect(); // TODO Or getBBox?\n    if (bbox.width > width) {\n      width = bbox.width;\n    }\n  });\n\n  // Add some padding\n  return width + options.X_TICK_GUTTER + 5;\n}\n", "/*\nBar chart - stacked bars\n*/\nimport * as d3 from \"d3\";\n\nimport { Chart } from \"./chart\";\nimport { makeDateFormatter } from \"./timeseries\";\n\nexport class Bar extends Chart {\n  parse(data) {\n    // Get distinct items from the list of Z values\n    this.Z = this.parseZ(data);\n    this.items = new Set(this.Z);\n\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d3.isoParse(d[0]),\n      (d) => d[2],\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    this.stack = d3\n      .stack()\n      .keys(this.items)\n      .value(([, group], key) => {\n        let item = group.get(key);\n        return item ? item[1] : 0;\n      })(indexed);\n\n    // Use the stack to determine the x and y-axis domains\n    this.X = [...indexed.keys()];\n    this.Y = [0, d3.max(this.stack[this.stack.length - 1], (d) => d[1])];\n\n    this.setColors(data);\n  }\n\n  // Since the X data is categorical, return all unique values\n  getDomainX() {\n    return new Set(this.X);\n  }\n\n  getDomainY() {\n    return this.Y;\n  }\n\n  render(elem) {\n    // Determine the size of the DOM element\n    const [width, height] = this.getDimensions(elem);\n    const dimensions = { width, height };\n    const margin = this.getMargin(width, height);\n\n    this.createSVG(elem, dimensions);\n\n    // Y-axis\n    const yScale = d3\n      .scaleLinear()\n      .domain(this.getDomainY())\n      .range(this.getRangeY(dimensions, margin));\n\n    let yAxis = d3\n      .axisLeft(yScale)\n      .tickValues(this.getTickValuesY())\n      .tickFormat(this.tickFormatY)\n      .tickSize(0)\n      .ticks(8);\n\n    // X-axis\n    const xScale = d3\n      .scaleBand()\n      .domain(this.getDomainX())\n      .range(this.getRangeX(dimensions, margin))\n      .padding(this.options.BAND_PADDING)\n      .align(0.1);\n\n    // NOTE The date formatter needs to be created because it uses a\n    // closure to determine a new year\n    // TODO A method to provide custom formatting\n    const dateFormatter = makeDateFormatter();\n    let xAxis = d3\n      .axisBottom(xScale)\n      .tickFormat(dateFormatter)\n      .tickSizeInner(this.options.X_TICK_SIZE);\n\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(0,${dimensions.height - margin.bottom + this.options.X_TICK_GUTTER})`,\n      )\n      .call(xAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(${margin.left - this.options.Y_TICK_GUTTER},0)`,\n      )\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove())\n      .call((g) =>\n        g\n          .selectAll(\".tick line\")\n          .clone()\n          .attr(\"stroke\", \"#888\") // Works for black or white background at 40% opacity\n          .attr(\"stroke-opacity\", 0.4)\n          .attr(\"x1\", this.options.Y_TICK_GUTTER)\n          .attr(\n            \"x2\",\n            dimensions.width -\n              margin.right -\n              margin.left +\n              this.options.Y_TICK_GUTTER,\n          ),\n      );\n\n    // Create a stacked bar chart\n    this.svg\n      .append(\"g\")\n      .selectAll()\n      .data(this.stack)\n      .join(\"g\")\n      .attr(\"fill\", (d) => this.getColor(d.key))\n      .selectAll(\"rect\")\n      .data((D) => D)\n      .join(\"rect\")\n      .attr(\"stroke-width\", this.options.BAR_STROKE_WIDTH)\n      .attr(\"x\", (d) => xScale(d.data[0]))\n      .attr(\"y\", (d) => yScale(d[1]))\n      .attr(\"height\", (d) => yScale(d[0]) - yScale(d[1]))\n      .attr(\"width\", xScale.bandwidth());\n  }\n}\n", "import * as d3 from \"d3\";\n\nexport const month = d3.utcFormat(\"%b\");\nexport const monthDay = d3.utcFormat(\"%b %-d\");\nexport const monthYear = d3.utcFormat(\"%b %Y\");\nexport const monthDayYear = d3.utcFormat(\"%b %-d, %Y\");\nexport const fullMonthDayYear = d3.utcFormat(\"%B %-d, %Y\");\n\nexport function makeDateFormatter() {\n  let lastYear = null;\n  return function (d) {\n    const year = d.getUTCFullYear();\n    if (lastYear !== year) {\n      lastYear = year;\n      return monthDayYear(d);\n    }\n    return monthDay(d);\n  };\n}\n\nexport function makeMonthlyDateFormatter() {\n  let lastYear = null;\n  return function (d) {\n    const year = d.getUTCFullYear();\n    if (lastYear !== year) {\n      lastYear = year;\n      return monthYear(d);\n    }\n    return month(d);\n  };\n}\n", "export function discreteColorMap(items, colorMap, start = 0.0, end = 1.0) {\n  const range = end - start;\n  const step = items.length > 1 ? range / items.length : range / 2;\n  return d3.map(items, (d, i) => colorMap(end - step * i - step / 2));\n}\n", "export const percentFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n  signDisplay: \"exceptZero\",\n});\n\nexport const priceFmt = new Intl.NumberFormat(\"en-US\", {\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const smallPriceFmt = new Intl.NumberFormat(\"en-US\", {\n  maximumSignificantDigits: 3,\n});\n\nexport const magFormatter = new Intl.NumberFormat(\"en-US\", {\n  notation: \"compact\",\n  compactDisplay: \"short\",\n  minimumFractionDigits: 1,\n  maximumFractionDigits: 2,\n});\n\nexport const percentAxisFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 0,\n  maximumFractionDigits: 0,\n  signDisplay: \"exceptZero\",\n});\n\nexport const preciseFormatter = new Intl.NumberFormat(\"en-US\", {\n  notation: \"compact\",\n  compactDisplay: \"short\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 3,\n});\n\nexport const volume = function (value) {\n  if (!value) return; // Never show 0\n  if (value >= 1e9) {\n    return `${value / 1e9}B`; // Show billions\n  }\n  return `${value / 1e6}M`; // Show millions\n};\n", "/*\nLine chart\n*/\nimport * as d3 from \"d3\";\n\nimport { Chart } from \"./chart\";\nimport { throttle } from \"./throttle\";\n\nexport class Line extends Chart {\n  render(elem) {\n    // If there is no data, do not render\n    if (!this.X.length) return;\n\n    // Determine the size of the DOM element\n    const [width, height] = this.getDimensions(elem);\n    const dimensions = { width, height };\n    const margin = this.getMargin(width, height);\n\n    this.createSVG(elem, dimensions);\n\n    // X-axis\n    this.xScale = d3\n      .scaleUtc()\n      .domain(this.getDomainX())\n      .range(this.getRangeX(dimensions, margin));\n\n    let xAxis = d3\n      .axisBottom(this.xScale)\n      .tickValues(this.getTickValuesX())\n      .tickFormat(this.tickFormatX)\n      .tickSizeInner(this.options.X_TICK_SIZE);\n\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(0,${dimensions.height - margin.bottom + this.options.Y_TICK_GUTTER})`,\n      )\n      .call(xAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    // Y-axis\n    this.yScale = d3\n      .scaleLinear()\n      .domain(this.getDomainY())\n      .range(this.getRangeY(dimensions, margin));\n\n    let yAxis = d3\n      .axisLeft(this.yScale)\n      .tickValues(this.getTickValuesY())\n      .tickFormat(this.tickFormatY)\n      .tickSize(0)\n      .ticks(8); // TODO Number of ticks\n\n    // Grid lines\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(${margin.left - this.options.X_TICK_GUTTER},0)`,\n      )\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove())\n      .call((g) =>\n        g\n          .selectAll(\".tick line\")\n          .clone()\n          .attr(\"stroke\", \"#888\") // Works for black or white background at 40% opacity\n          .attr(\"stroke-opacity\", 0.4)\n          .attr(\"transform\", `translate(${this.options.X_TICK_GUTTER},0)`)\n          .attr(\"x2\", dimensions.width - margin.left - margin.right),\n      );\n\n    // Plot the line\n    const line = d3\n      .line()\n      .defined((i) => this.D[i])\n      .x((i) => this.xScale(this.X[i]))\n      .y((i) => this.yScale(this.Y[i]));\n\n    this.path = this.svg\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", this.options.STROKE_WIDTH)\n      .selectAll(\"path\")\n      .data(this.grouping)\n      .join(\"path\")\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"stroke\", ([d]) => this.getColor(d));\n\n    // Dot - shows nearest point during pointer events\n    this.dot = this.svg.append(\"g\").style(\"display\", \"none\");\n    this.circle = this.dot.append(\"circle\").attr(\"r\", this.options.DOT_RADIUS);\n  }\n\n  getLegend() {\n    // Return the z items along with their colors\n    return d3.map(this.items, (d) => {\n      return Object.assign({ color: this.getColor(d.key) }, d);\n    });\n  }\n\n  placeDot(i) {\n    // Place a dot at the given index\n    const x = this.xScale(this.X[i]);\n    const y = this.yScale(this.Y[i]);\n    const z = this.Z[i];\n    this.dot.style(\"display\", null).attr(\"transform\", `translate(${x},${y})`);\n    this.circle.attr(\"fill\", this.getColor(z));\n  }\n\n  hideDot() {\n    this.dot.style(\"display\", \"none\");\n  }\n\n  noHighlight() {\n    this.path\n      .attr(\"opacity\", 1.0)\n      .attr(\"stroke-width\", this.options.STROKE_WIDTH);\n  }\n\n  highlight(z) {\n    // Hide paths that aren't the currently selected path\n    this.path\n      .attr(\"opacity\", ([elem]) =>\n        elem === z ? 1.0 : this.options.BACKGROUND_OPACITY,\n      )\n      .attr(\"stroke-width\", ([elem]) =>\n        elem === z\n          ? this.options.HIGHLIGHT_STROKE_WIDTH\n          : this.options.STROKE_WIDTH,\n      );\n  }\n\n  enableHover(move, leave) {\n    let prevIndex = null;\n\n    // Determine the closest point to the cursor\n    const pointermove = (evt) => {\n      const [xm, ym] = d3.pointer(evt);\n      const index = d3.least(this.I, (i) =>\n        Math.hypot(this.xScale(this.X[i]) - xm, this.yScale(this.Y[i]) - ym),\n      );\n\n      // Do not place a tooltip if no point was found\n      if (typeof index === \"undefined\") return;\n\n      // Only trigger the callback when the index changes\n      if (prevIndex && prevIndex == index) return;\n\n      this.placeDot(index);\n\n      const x = this.X[index];\n      const y = this.Y[index];\n      const z = this.Z[index];\n\n      let data = {\n        x: x,\n        y: y,\n        z: z,\n        dx: this.xScale(x),\n        dy: this.yScale(y),\n        fx: this.formatX(x),\n        fy: this.formatY(y),\n        fz: this.formatZ(z),\n      };\n\n      if (move) {\n        move.call(this, data);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      this.hideDot();\n      if (leave) {\n        leave.call(this);\n      }\n    };\n\n    this.svg\n      .on(\"pointermove\", throttle(pointermove, this.options.eventLatency))\n      .on(\"pointerleave\", pointerleave)\n      .on(\"touchstart\", (evt) => {\n        pointermove(evt);\n        evt.preventDefault();\n      });\n  }\n}\n", "export function throttle(fn, timeout) {\n  var free = true;\n  return function () {\n    if (free) {\n      fn.apply(this, arguments);\n      free = false;\n      setTimeout(() => {\n        free = true;\n      }, timeout);\n    }\n  };\n}\n", "/*\nOHLCV chart\n*/\nimport * as d3 from \"d3\";\n\nimport { maxTickWidth } from \"./layout\";\nimport { Chart } from \"./chart\";\nimport { makeDateFormatter } from \"./timeseries\";\nimport { throttle } from \"./throttle\";\nimport { volume } from \"./formats\";\n\nexport class OHLCV extends Chart {\n  parse(data) {\n    this.X = d3.map(data, (d) => d3.isoParse(d[0]));\n    this.Yo = d3.map(data, (d) => d[1]);\n    this.Yh = d3.map(data, (d) => d[2]);\n    this.Yl = d3.map(data, (d) => d[3]);\n    this.Yc = d3.map(data, (d) => d[4]);\n    this.Yv = d3.map(data, (d) => d[5]);\n    this.I = d3.range(this.X.length);\n  }\n\n  getMargin(width, height) {\n    const margin = {\n      top: 15,\n      right: 25,\n      bottom: 25,\n      left: 40,\n    };\n\n    // Adjust the left margin to accommodate the price ticks\n    margin.left = maxTickWidth(\n      margin,\n      height,\n      this.getDomainY(),\n      this.tickFormatY,\n      this.options,\n    );\n\n    // Adjust the right margin to accommodate the volume tick\n    margin.right = maxTickWidth(\n      margin,\n      height,\n      this.yDomainVolume,\n      volume,\n      this.options,\n    );\n    return margin;\n  }\n\n  getDomainX() {\n    return d3.extent(this.X);\n  }\n\n  getDomainY() {\n    // TODO How to pad?\n    // TODO How to set multiple domains? Data object\n    this.minPrice = d3.min(this.Yl); // Sets the initial animation y-coord\n    const maxPrice = d3.max(this.Yh);\n    this.yDomain = [\n      this.minPrice,\n      maxPrice + (maxPrice - this.minPrice) * 0.05,\n    ];\n    this.yDomainVolume = [0, d3.max(this.Yv)];\n    return this.yDomain;\n  }\n\n  getColor(index) {\n    return this.options.OHLC_COLORS[\n      1 + Math.sign(this.Yo[index] - this.Yc[index])\n    ];\n  }\n\n  render(elem) {\n    // Determine the size of the DOM element\n    const [width, height] = this.getDimensions(elem);\n    const dimensions = { width, height };\n    const margin = this.getMargin(width, height);\n\n    // TODO How to generalize different chart sections? sub-axes?\n    const chartHeight = height - margin.top - margin.bottom;\n    this.chartHeight = chartHeight;\n    const pricePortion = 0.9;\n    const priceHeight = chartHeight * pricePortion;\n\n    const yRange = [margin.top + priceHeight, margin.top];\n    const yRangeVolume = [margin.top + chartHeight, margin.top + priceHeight];\n\n    const yFormat = \",f\";\n    const yLabel = \"\";\n\n    // NOTE If dates are missing, we can't use the timeWeek ranges without\n    // checking if the tick has values\n    // TODO Number of x-ticks, number of y-ticks - function of width?\n    let interval = parseInt(this.X.length / 10);\n    if (interval < 1) {\n      interval = 1;\n    }\n\n    let xTicks = d3.filter(this.X, (d, i) => i % interval === 0);\n\n    // Construct scales and axes\n    // NOTE scaleBand takes all 'categorical' x-axis items - not just extent\n    // TODO Play further with padding and align\n    this.xScale = d3\n      .scaleBand(this.X, this.getRangeX(dimensions, margin))\n      .padding(this.options.BAND_PADDING)\n      .align(0.1);\n    const yScale = d3.scaleLinear(this.getDomainY(), yRange);\n    const yScaleVolume = d3.scaleLinear(this.yDomainVolume, yRangeVolume);\n\n    // NOTE The date formatter needs to be created because it uses a\n    // closure to determine a new year\n    // TODO A method to provide custom formatting\n    const dateFormatter = makeDateFormatter();\n    const xAxis = d3\n      .axisBottom(this.xScale)\n      .tickFormat(dateFormatter)\n      .tickValues(xTicks)\n      .tickSize(this.options.X_TICK_SIZE);\n\n    // The band width will be used for correctly positioning the tooltip\n    this.bandWidth = this.xScale.step();\n\n    // TODO Set number of ticks\n    const yAxis = d3\n      .axisLeft(yScale)\n      .ticks(priceHeight / 40, yFormat)\n      .tickSize(this.options.Y_TICK_SIZE);\n\n    const yAxisVolume = d3\n      .axisRight(yScaleVolume)\n      .ticks(1) // Never show more than 1 non-zero tick for the volume\n      .tickFormat(volume)\n      .tickSize(3);\n\n    // Create SVG\n    this.createSVG(elem, dimensions);\n\n    const bandPadding = (this.bandWidth * this.options.BAND_PADDING) / 2;\n\n    // X-axis\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(${bandPadding},${height - margin.bottom + this.options.X_TICK_GUTTER})`,\n      )\n      .call(xAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    // Price y-axis\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\n        \"transform\",\n        `translate(${margin.left - this.options.Y_TICK_GUTTER},0)`,\n      )\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove())\n      .call((g) =>\n        g\n          .selectAll(\".tick line\")\n          .clone()\n          .attr(\"stroke\", \"#bbb\") // Works for black or white background at 50% opacity\n          .attr(\"stroke-opacity\", 0.5)\n          .attr(\"x1\", this.options.Y_TICK_GUTTER)\n          .attr(\n            \"x2\",\n            width + this.options.Y_TICK_GUTTER - margin.left - margin.right,\n          ),\n      )\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", -margin.left)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(yLabel),\n      );\n\n    // Volume y-axis\n    this.svg\n      .append(\"g\")\n      .style(\"font-size\", this.options.FONT_SIZE)\n      .attr(\"transform\", `translate(${width - margin.right},0)`)\n      .call(yAxisVolume)\n      .call((g) => g.select(\".domain\").remove())\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", -margin.left)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(yLabel),\n      );\n\n    // Plot OHLC candle sticks\n    const g = this.svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-linecap\", \"butt\") // NOTE using 'square' distorts size\n      .selectAll(\"g\")\n      .data(this.I)\n      .join(\"g\")\n      .attr(\n        \"transform\",\n        (i) => `translate(${this.xScale(this.X[i]) + this.bandWidth / 2.0},0)`,\n      );\n\n    g.append(\"line\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-width\", 1)\n      .attr(\"opacity\", 0.8)\n      .attr(\"y1\", yScale(this.minPrice))\n      .attr(\"y2\", yScale(this.minPrice))\n      .transition()\n      .duration(this.options.ANIMATION_DURATION_MS)\n      .attr(\"y1\", (i) => yScale(this.Yl[i]))\n      .attr(\"y2\", (i) => yScale(this.Yh[i]));\n\n    g.append(\"line\")\n      .attr(\"stroke-width\", this.xScale.bandwidth())\n      .attr(\"stroke\", (i) => this.getColor(i))\n      .attr(\"y1\", yScale(this.minPrice))\n      .attr(\"y2\", yScale(this.minPrice))\n      .transition()\n      .duration(this.options.ANIMATION_DURATION_MS)\n      .attr(\"y1\", (i) => yScale(this.Yo[i]))\n      .attr(\"y2\", (i) => yScale(this.Yc[i]));\n\n    // Plot volume\n    const vol = this.svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-linecap\", \"butt\") // NOTE using 'square' distorts length\n      .selectAll(\"g\")\n      .data(this.I)\n      .join(\"g\")\n      .attr(\n        \"transform\",\n        (i) => `translate(${this.xScale(this.X[i]) + this.bandWidth / 2.0},0)`,\n      );\n\n    vol\n      .append(\"line\")\n      .attr(\"y1\", yScaleVolume(0))\n      .attr(\"y2\", yScaleVolume(0))\n      .attr(\"stroke-width\", this.xScale.bandwidth())\n      .attr(\"stroke\", (i) => this.getColor(i))\n      .style(\"opacity\", this.options.VOLUME_OPACITY)\n      .transition()\n      .duration(this.options.ANIMATION_DURATION_MS)\n      .attr(\"y2\", (i) => yScaleVolume(this.Yv[i]));\n  }\n\n  enableHover(move, leave) {\n    // Enable hover events for the chart. On move, determine which band is being\n    // hovered over and send an object of its OHLCV data to the move callback.\n    // The leave callback is triggered when the pointer leaves the SVG elem\n    // Calculate the Voronoi of a single line of x-coordinates\n    const points = d3.map(this.X, (d) => [\n      this.xScale(d) + this.bandWidth / 2,\n      1,\n    ]);\n    const delaunay = d3.Delaunay.from(points);\n\n    let prevIndex = null;\n\n    const pointermove = (evt) => {\n      const [xm] = d3.pointer(evt);\n      const index = delaunay.find(xm, 1);\n\n      // Only trigger the callback when the index changes\n      if (prevIndex && prevIndex == index) {\n        return;\n      }\n\n      prevIndex = index;\n\n      // Include the index's OHLCV data and a change from the last close\n      let data = {\n        x: this.X[index],\n        o: this.Yo[index],\n        h: this.Yh[index],\n        l: this.Yl[index],\n        c: this.Yc[index],\n        v: this.Yv[index],\n        // TODO Return formatted values?\n      };\n\n      if (index > 0) {\n        data.prev = this.Yc[index - 1];\n        if (data.prev) {\n          data.delta = data.c - data.prev;\n          data.percent = data.delta / data.prev;\n          data.color = this.options.OHLC_COLORS[1 + Math.sign(-data.delta)];\n        }\n      }\n\n      // TODO Always enable highlight?\n      if (move) {\n        move.call(this, data);\n      }\n    };\n\n    this.svg.on(\n      \"pointermove\",\n      throttle(pointermove, this.options.eventLatency),\n    );\n\n    if (leave) {\n      this.svg.on(\"pointerleave\", leave);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_d3", "__commonJSMin", "exports", "module", "rates_exports", "__export", "Rates", "d3", "d3", "d3", "Options", "options", "d3", "getDimensions", "elem", "ratio", "maxWidth", "minWidth", "minHeight", "chart", "width", "height", "maxTickWidth", "defaults", "domain", "format", "options", "hidden", "scale", "axis", "labels", "bbox", "Chart", "data", "options", "__publicField", "Options", "width", "height", "defined", "d", "i", "value", "key", "dimensions", "margin", "z", "elem", "getDimensions", "d3", "d3", "month", "monthDay", "monthYear", "monthDayYear", "fullMonthDayYear", "discreteColorMap", "items", "colorMap", "start", "end", "range", "step", "d", "i", "percentFormatter", "priceFmt", "smallPriceFmt", "magFormatter", "percentAxisFormatter", "preciseFormatter", "d3", "throttle", "fn", "timeout", "free", "Line", "Chart", "elem", "width", "height", "dimensions", "margin", "xAxis", "g", "yAxis", "line", "i", "I", "d", "x", "y", "z", "move", "leave", "prevIndex", "pointermove", "evt", "xm", "ym", "index", "data", "pointerleave", "throttle", "d3", "percentChange", "Q", "d", "Rates", "Line", "__publicField", "v", "i", "elem", "width", "height", "margin", "maxTickWidth", "start", "end", "years", "year", "data", "hide", "values", "item", "obj", "defined", "items", "abbrevs", "colors", "discreteColorMap", "value", "key"]
}
