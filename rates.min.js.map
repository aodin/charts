{
  "version": 3,
  "sources": ["external-global-plugin:d3", "rates.js", "../node_modules/@aodin/charts/src/area.js", "../node_modules/@aodin/charts/src/chart.js", "../node_modules/@aodin/charts/src/colors.js", "../node_modules/@aodin/charts/src/layout.js", "../node_modules/@aodin/charts/src/parsers.js", "../node_modules/@aodin/charts/src/text.js", "../node_modules/@aodin/charts/src/ticks.js", "../node_modules/@aodin/charts/src/throttle.js", "../node_modules/@aodin/charts/src/bar.js", "../node_modules/@aodin/charts/src/timeseries.js", "../node_modules/@aodin/charts/src/candlestick.js", "../node_modules/@aodin/charts/src/formats.js", "../node_modules/@aodin/charts/src/line.js", "../node_modules/@aodin/charts/src/magnitude.js", "../node_modules/@aodin/charts/src/options.js", "../node_modules/@aodin/charts/src/pie.js", "../node_modules/@aodin/charts/src/zoom.js"],
  "sourcesContent": ["module.exports = d3", "/*\nExample exchange rate chart that extends a line chart\n*/\nimport { TimeSeriesChart, percentChange, quarter } from \"@aodin/charts\";\n\nfunction parseRateArray(d) {\n  // x, z, y\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[2],\n    z: d[1],\n  };\n}\n\nexport { percentChange, quarter };\n\nclass RatesChart extends TimeSeriesChart {\n  yFormat = d3.format(\",~%\");\n\n  constructor(data) {\n    super(data);\n    this.screenHeightPercent(0.75);\n    this.useContinuousScheme(d3.interpolateRainbow, 0.1, 0.9);\n  }\n\n  parseData(data) {\n    return d3.map(data.values, parseRateArray);\n  }\n\n  parseItems(data) {\n    return data.items;\n  }\n\n  parseZ(data) {\n    return d3.map(this.items, d => d.abbrev);\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.items, (d) => {\n      return Object.assign({color: this.colors(d.abbrev)}, d);\n    });\n  }\n\n  render(selector) {\n    super.render(selector);\n\n    const tooltipID = \"chart-tooltip\";\n\n    const tooltip = d3\n      .select(\"body\")\n      .append(\"div\")\n      .attr(\"id\", tooltipID)\n      .style(\"pointer-events\", \"none\")\n      .style(\"position\", \"absolute\")\n      .style(\"opacity\", 0)\n      .style(\"font-size\", \"13px\");\n\n    // TODO How to get tooltip dimensions directly?\n    const bbox = document.getElementById(tooltipID);\n    const rect = document.querySelector(selector);\n\n    const names = this.legend.reduce((acc, o) => {\n      acc[o.abbrev] = o.name;\n      return acc;\n    }, {});\n\n    const onMove = (data) => {\n      this.highlight(data.z);\n\n      // Set text of tooltip, then set coordinates\n      const name = names[data.z];\n      const q = rates.quarter(data.x)\n      const percent = rates.percentChange(data.y);\n      tooltip.html(`<strong>${name}</strong></br><em>${q}</em></br>${percent}`);\n\n      let offsetY = -bbox.offsetHeight - 5;\n      let offsetX = 0;\n      if (data.dx > (5 * rect.offsetWidth) / 6) {\n        // Right side of chart\n        offsetX = -bbox.offsetWidth - 10;\n        tooltip.style(\"text-align\", \"right\");\n      } else {\n        // Left side of chart\n        tooltip.style(\"text-align\", \"left\");\n      }\n\n      if (data.dy < (rect.offsetHeight / 4)) {\n        offsetY = 5;\n      }\n\n      tooltip\n        .style(\"opacity\", 1)\n        .style(\"left\", `${data.dx + rect.offsetLeft + offsetX}px`)\n        .style(\"top\", `${data.dy + rect.offsetTop + offsetY}px`);\n    }\n\n    const onLeave = () => {\n      this.noHighlight();\n      tooltip.style(\"opacity\", 0);\n    }\n\n    this.onEvent(onMove, onLeave);\n\n    // Draw the legend - pass as selectors?\n    const legend = document.querySelector(\"#legend\");\n    const template = document.querySelector(\"#legendTemplate\");\n\n    this.legend.forEach((item) => {\n      const clone = template.content.cloneNode(true);\n      const div = clone.querySelector(\"div\");\n      div.dataset.abbrev = item.abbrev;\n      div.dataset.hidden = \"\"; // Initial show/hide state can be set here\n\n      clone\n        .querySelector(\"rect\")\n        .setAttribute(\"fill\", item.color);\n      clone.querySelector(\"span\").textContent = `${item.name}`;\n      legend.appendChild(clone);\n\n      // Create hover events that highlight chart on legend hover, but only if it's active\n      // NOTE This creates strange effects on mobile\n      // div.addEventListener(\"mouseover\", (elem) => {\n      //   if (div.dataset.hidden === \"\") {\n      //     this.highlight(item.abbrev);\n      //   } else {\n      //     this.noHighlight();\n      //   }\n      // });\n\n      // Show only that item when double click\n      div.addEventListener(\"dblclick\", (evt) => {\n        const z = [];\n        // TODO Another approach: if the currently double clicked item is the only one\n        // shown, then show everything\n        if (div.dataset.hidden === \"\") {\n          // Hide everything except the current item\n          Array.from(legend.children).forEach(elem => {\n            if (elem.dataset.abbrev === item.abbrev) {\n              elem.dataset.hidden = \"\";\n            } else {\n              z.push(elem.dataset.abbrev);\n              elem.dataset.hidden = true;\n            }\n          });\n        } else {\n          // If the item is already hidden, just show everything again\n          Array.from(legend.children).forEach(elem => {\n            elem.dataset.hidden = \"\";\n          });\n        }\n        z.length ? this.hide(...z) : this.showAll();\n        evt.preventDefault();\n      });\n\n      // Hide the item on single click, unless it is already hidden, then show\n      div.addEventListener(\"click\", (evt) => {\n        if (div.dataset.hidden === \"\") {\n          this.hide(item.abbrev);\n          div.dataset.hidden = \"true\";\n        } else {\n          this.show(item.abbrev);\n          div.dataset.hidden = \"\";\n        }\n      });\n    });\n  }\n}\n\nexport function Rates(data) {\n  return new RatesChart(data);\n}\n", "/*\nArea chart\n*/\nimport * as d3 from \"d3\";\n\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { maxLabelSize } from \"./ticks\";\nimport { throttle } from \"./throttle\";\n\nexport { parse3dArray, parseTimeSeries3dArray };\n\nexport class AreaChart extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Area charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      SCREEN_HEIGHT_PERCENT: 0.5,\n      DURATION_MS: 500,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      Y_AXIS_RIGHT: false,\n      COLORS: d3.schemeCategory10, // TODO There's no way to change the default yet\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        return item && item.y ? item.y : 0;\n      })(indexed);\n\n    // Largest items are returned first, since the stack areas are all drawn from zero\n    return stack.reverse();\n  }\n\n  get stack() {\n    // Only visible data - hidden items are all zero\n    return this.getStack(this.visibleData);\n  }\n\n  get fullStack() {\n    // All data\n    return this.getStack(this.data);\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    // TODO SHould legend order be reversed?\n    return d3.map(this.Z.slice().reverse(), (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get visibleData() {\n    // TODO memoization\n    // return d3.filter(this.data, (d) => !this.hidden.has(d.z));\n    // Set hidden values to zero\n    return d3.map(this.data, (d) =>\n      this.hidden.has(d.z) ? { x: d.x, y: 0, z: d.z } : d,\n    );\n  }\n\n  get xDomain() {\n    // By default, don't re-calculate the x-axis\n    return d3.extent(d3.map(this.data, (d) => d.x));\n  }\n\n  get yDomain() {\n    // Always show the full y Axis\n    return [0, d3.max(this.fullStack[0], (d) => d[1])];\n  }\n\n  get xScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0])\n      .nice();\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(3).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    if (this.config.Y_AXIS_RIGHT) {\n      g.call(d3.axisRight(y).tickSize(0).tickFormat(this.yFormat));\n    } else {\n      g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n    }\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"));\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced, but we still need room for the x-scale tick labels\n      this.layout.pad.left = 15;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(selector, this.config);\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    this.x = this.xScale;\n    this.y = this.yScale;\n\n    // Start with the SVG visible - this can be set to 0 for \"fade in\"\n    this.svg.attr(\"opacity\", 1.0);\n\n    // Create a clip path to hide any overflow content\n    this.svg\n      .append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", \"inner-clip-path\")\n      .append(\"rect\")\n      .attr(\"width\", this.layout.width)\n      .attr(\"height\", this.layout.height);\n\n    this.svg.attr(\"clip-path\", \"url(#inner-clip-path)\");\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    let yTransform = `translate(${this.layout.pad.left - this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    if (this.config.Y_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.pad.left + this.layout.innerWidth + this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    }\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\"transform\", yTransform);\n\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    const gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    // Set initial state\n    this.gx.call(this.xAxis.bind(this), this.x).attr(\"opacity\", 1.0);\n    this.gy.call(this.yAxis.bind(this), this.y);\n    this.gGrid.call(this.grid.bind(this), this.x, this.y);\n\n    // Draw the zero state areas\n    const area = d3\n      .area()\n      .x((d) => this.x(d.data[0]))\n      .y0((d) => this.y(0))\n      .y1((d) => this.y(0));\n\n    this.areas = gInner\n      .append(\"g\")\n      .selectAll()\n      .data(this.stack)\n      .join(\"path\")\n      .attr(\"fill\", (d) => this.colors(d.key))\n      .attr(\"class\", (d) => className(d.key))\n      .attr(\"d\", area);\n\n    this.update(this.x, this.y);\n  }\n\n  update(x, y) {\n    // Draw visible areas - always from 0\n    const area = d3\n      .area()\n      .x((d) => x(d.data[0]))\n      .y0((d) => y(0))\n      .y1((d) => y(d[1]));\n\n    this.areas\n      .data(this.stack)\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", area);\n  }\n\n  noHighlight() {\n    // Reset all areas to default\n    // this.areas.attr(\"fill\", (d) => this.colors(d.key));\n    // this.areas.attr(\"opacity\", 1.0);\n  }\n\n  highlight(z) {\n    // TODO Make the given z more prominent - two possibilities\n    // this.areas.attr(\"fill\", (d) => d.key === z ? this.colors(d.key) : \"#ddd\");\n    // this.areas.attr(\"opacity\", (d) => d.key === z ? 1.0 : this.config.BACKGROUND_OPACITY);\n  }\n\n  onEvent(move, leave) {\n    const xs = [...d3.group(this.data, (d) => d.x).keys()];\n    const coords = d3.map(xs, this.x);\n\n    // Organize the data by key and x\n    const indexed = d3.index(\n      this.data,\n      (d) => d.z,\n      (d) => d.x,\n    );\n\n    const pointermove = (evt, d) => {\n      let [xm, ym] = d3.pointer(evt);\n      const index = d3.bisectCenter(coords, xm);\n      const point = indexed.get(d.key).get(xs[index]);\n\n      // Data that will be provided to the callback\n      const data = {\n        x: point.x,\n        y: point.y,\n        z: point.z,\n        dx: xm + this.layout.pad.left,\n        dy: ym + this.layout.pad.top,\n      };\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt, d) => {\n      if (leave) {\n        leave.call(this, d.key);\n      }\n    };\n\n    this.areas\n      .on(\"pointermove\", throttle(pointermove, 20.83)) // 48 fps\n      .on(\"pointerleave\", pointerleave);\n  }\n\n  toggle() {\n    this.update(this.x, this.y);\n  }\n}\n\nexport function Area(data, parser) {\n  return new AreaChart(data, parser);\n}\n\nexport class TimeSeriesAreaChart extends AreaChart {\n  get xScale() {\n    // Never re-calculate the x-axis\n    return d3\n      .scaleUtc()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  sortData(data) {\n    data.sort((a, b) => a.x - b.x);\n    return data;\n  }\n\n  parseData(data, parser) {\n    // Sort timeseries data in ascending order\n    return this.sortData(super.parseData(data, parser));\n  }\n}\n\nexport function TimeSeriesArea(data, parser) {\n  return new TimeSeriesAreaChart(data, parser);\n}\n\nexport class TimeSeriesSharesChart extends TimeSeriesAreaChart {\n  yFormat = d3.format(\".0%\");\n\n  constructor(data, parser) {\n    super(data, parser);\n\n    // Determine the total per x\n    this.totals = d3.rollup(\n      this.data,\n      (v) => d3.sum(v, (d) => d.y),\n      (d) => d.x,\n    );\n  }\n\n  // Use the stack to calculate shares\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        const total = this.totals.get(item.x);\n        return item && item.y && total ? item.y / total : 0;\n      })(indexed);\n\n    // Largest items are returned first, since the stack areas are all drawn from zero\n    return stack.reverse();\n  }\n}\n\nexport function TimeSeriesShares(data, parser) {\n  return new TimeSeriesSharesChart(data, parser);\n}\n", "import * as d3 from \"d3\";\n\nimport { quantizeScheme } from \"./colors\";\n\nexport class Chart {\n  // Base class for charts\n  // Currently only has some common chained config methods\n\n  constructor(data, parser = (d) => d) {}\n\n  /* Config chained methods */\n  screenHeightPercent(value) {\n    this.config.SCREEN_HEIGHT_PERCENT = value;\n    return this;\n  }\n\n  animationDuration(value) {\n    this.config.DURATION_MS = value;\n    return this;\n  }\n\n  noAnimation() {\n    return this.animationDuration(0);\n  }\n}\n\nexport class CategoricalChart extends Chart {\n  // Adds additional chained config methods for schemes and hidden state\n\n  constructor(data, parser = (d) => d) {\n    // Items can be dynamically hidden from the chart\n    super(data, parser);\n    this.hidden = new d3.InternSet();\n  }\n\n  /* Chained config methods */\n  backgroundOpacity(value) {\n    this.config.BACKGROUND_OPACITY = value;\n    return this;\n  }\n\n  yAxisRight() {\n    // The y axis ticks and labels will be shown on the right of the chart\n    this.config.Y_AXIS_RIGHT = true;\n    return this;\n  }\n\n  useDiscreteScheme(scheme) {\n    this.colors = d3.scaleOrdinal().domain(this.Z).range(scheme);\n    return this;\n  }\n\n  useContinuousScheme(scheme, min = 0.0, max = 1.0) {\n    return this.useDiscreteScheme(\n      quantizeScheme(this.Z.length, scheme, min, max),\n    );\n  }\n\n  invertScheme() {\n    this.colors = this.colors.range(this.colors.range().reverse());\n    return this;\n  }\n\n  startHidden() {\n    // The first render will have all items hidden\n    this.hidden = new d3.InternSet(this.Z);\n    return this;\n  }\n  /* End chained config methods */\n\n  hide(...z) {\n    // Add the given z elements to the hidden set\n    this.hidden = this.hidden.union(new d3.InternSet(z));\n    this.toggle();\n  }\n\n  show(...z) {\n    // Remove the given z elements from the hidden set\n    this.hidden = this.hidden.difference(new d3.InternSet(z));\n    this.toggle();\n  }\n\n  setHidden(...z) {\n    this.hidden = new d3.InternSet(z);\n  }\n\n  hideAll() {\n    this.hidden = new d3.InternSet(this.Z);\n    this.toggle();\n  }\n\n  showAll() {\n    this.hidden.clear();\n    this.toggle();\n  }\n}\n", "import * as d3 from \"d3\";\n\nexport function quantizeScheme(n, scheme, min = 0.0, max = 1.0) {\n  if (n === 1) {\n    // If there is only one item, just use the middle of the scheme\n    return [scheme((max - min) / 2.0 + min)];\n  }\n  return d3.quantize((t) => scheme(t * (max - min) + min), n);\n}\n", "import * as d3 from \"d3\";\n\n/*\nMost of the layout operations are placing a rectangle within another rectangle.\nWhat is the most generic way to do this?\n*/\n\nexport class Pad {\n  constructor(top, right, bottom, left) {\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n}\n\nexport function EqualPad(value) {\n  return new Pad(value, value, value, value);\n}\n\nexport function DefaultPad() {\n  return new Pad(15, 15, 25, 25);\n}\n\nexport class Layout {\n  constructor(width, height, pad) {\n    this.width = width;\n    this.height = height;\n    this.pad = pad || DefaultPad();\n  }\n\n  get rangeX() {\n    return [this.pad.left, this.width - this.pad.right];\n  }\n\n  get rangeY() {\n    return [this.height - this.pad.bottom, this.pad.top];\n  }\n\n  get innerWidth() {\n    return this.width - this.pad.left - this.pad.right;\n  }\n\n  get innerHeight() {\n    return this.height - this.pad.top - this.pad.bottom;\n  }\n\n  get innerMinimum() {\n    return d3.min([this.innerWidth, this.innerHeight]);\n  }\n\n  get midpoint() {\n    return [this.width / 2, this.height / 2];\n  }\n}\n\nexport function getLayout(\n  elem,\n  {\n    minWidth = 400,\n    maxWidth = undefined,\n    minHeight = 300,\n    maxHeight = undefined,\n    screenHeightPercent = 0.5,\n  } = {},\n) {\n  const chart = document.querySelector(elem);\n  let width = d3.max([chart.offsetWidth, minWidth]);\n  if (maxWidth) {\n    width = d3.min([width, maxWidth]);\n  }\n\n  let height = window.innerHeight * screenHeightPercent;\n  height = d3.max([height, minHeight]);\n  if (maxHeight) {\n    height = d3.min([height, maxHeight]);\n  }\n  return new Layout(width, height, DefaultPad());\n}\n\nexport function maxTickWidth(defaults, height, domain, format, options) {\n  // Create a fake axis to test label tick size\n  const hidden = d3\n    .select(\"body\")\n    .append(\"svg\")\n    .attr(\"width\", 100)\n    .attr(\"height\", height)\n    .style(\"visibility\", \"hidden\"); // \"display: none\" does not work\n\n  let scale = d3\n    .scaleLinear()\n    .domain(domain)\n    .range([height - defaults.bottom, defaults.top]);\n\n  let axis = d3\n    .axisLeft(scale)\n    .tickFormat(format) // Can be null\n    .tickSize(0)\n    .ticks(8); // TODO Number of ticks as an option\n\n  const g = hidden.append(\"g\").style(\"font-size\", options.FONT_SIZE).call(axis);\n\n  // Measure the tick labels\n  const labels = g.selectAll(\".tick text\");\n\n  let width = 0;\n  labels.each(function () {\n    const bbox = this.getBoundingClientRect(); // TODO Or getBBox?\n    if (bbox.width > width) {\n      width = bbox.width;\n    }\n  });\n\n  // Remove the axis\n  hidden.remove();\n\n  // Pad\n  return width + options.X_TICK_GUTTER + 5;\n}\n\nexport function appendSVG(selector, width, height) {\n  // Append an SVG element to the selected element\n  return d3\n    .select(selector)\n    .append(\"svg\")\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: intrinsic;\")\n    .style(\"-webkit-tap-highlight-color\", \"transparent\")\n    .style(\"overflow\", \"visible\");\n}\n\nexport function layoutSVG(selector, config) {\n  // Return the SVG elements and its layout\n  const elem = d3.select(selector);\n  if (!elem.node()) {\n    throw new Error(`Unable to find a DOM element for selector '${selector}'`);\n  }\n\n  if (elem.node().tagName === \"svg\") {\n    const svg = elem;\n    const width = +svg.attr(\"width\");\n    const height = +svg.attr(\"height\");\n    // TODO Fallback to viewbox\n    if (width && height) {\n      return [svg, new Layout(width, height)];\n    } else {\n      // TODO SVGs must have a width or height or the defaults will be returned\n      const layout = getLayout(selector, {\n        screenHeightPercent: config.SCREEN_HEIGHT_PERCENT,\n      });\n      return [svg, layout];\n    }\n  }\n\n  const layout = getLayout(selector, {\n    screenHeightPercent: config.SCREEN_HEIGHT_PERCENT,\n  });\n  const svg = appendSVG(selector, layout.width, layout.height);\n  return [svg, layout];\n}\n", "import * as d3 from \"d3\";\n\nexport function parseArrayOHLCV(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    o: d[1],\n    h: d[2],\n    l: d[3],\n    c: d[4],\n    v: d[5],\n  };\n}\n\nexport function parseVerboseOHLCV(d) {\n  return {\n    x: d3.isoParse(d.date),\n    o: d.open,\n    h: d.high,\n    l: d.low,\n    c: d.close,\n    v: d.volume,\n  };\n}\n\nexport function parse3dArray(d) {\n  return {\n    x: d[0],\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport function parseTimeSeries3dArray(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[1],\n    z: d[2],\n  };\n}\n", "export function className(value) {\n  // Sanitize the given string so it can be used as a class name\n  value = String(value).trim();\n  if (!value) return value;\n\n  // Class names cannot contain spaces\n  value = value.replace(\" \", \"_\");\n\n  // Class names cannot start with a number\n  if (!isNaN(value.charAt(0))) {\n    value = \"_\" + value;\n  }\n\n  return value;\n}\n", "import * as d3 from \"d3\";\n\nexport function maxLabelSize(svg, layout, scale, format = null, cls = \"\") {\n  // Create a fake axis to test label tick size\n  // Does not include the tick size or padding, is just the label width\n  // This access should be part of the current chart's selection and have the same\n  // class values in order to correctly match any CSS that changes label sizes\n  const hidden = svg\n    .append(\"g\")\n    .attr(\"width\", layout.innerWidth)\n    .attr(\"height\", layout.innerHeight)\n    .attr(\"class\", cls)\n    .style(\"visibility\", \"hidden\"); // \"display: none\" does not work\n\n  const axis = d3.axisLeft(scale).tickFormat(format); // Can be null\n  const g = hidden.call(axis);\n\n  // Measure the tick labels\n  const labels = g.selectAll(\".tick text\");\n\n  let width = 0;\n  let height = 0;\n  labels.each(function () {\n    const bbox = this.getBoundingClientRect(); // TODO Or getBBox?\n    if (bbox.width > width) {\n      width = bbox.width;\n    }\n    if (bbox.height > height) {\n      height = bbox.height;\n    }\n  });\n\n  hidden.remove();\n  return [width, height];\n}\n\n/*\nIn order to filter categorical ticks, we need:\n1. the width of the largest tick label\n2. the total available width for the axes in the layout\n3. the interval that will fit that largest label without overlap\n4. then filter the available tick labels by the interval\n*/\nexport function filterTicks(ticks, layout, labelWidth) {\n  const count = parseInt(layout.innerWidth / (labelWidth + 1)) + 1;\n  const interval = d3.max([parseInt(Math.ceil(ticks.length / count)), 1]);\n  return d3.filter(ticks, (d, i) => i % interval === 0);\n}\n", "export function throttle(fn, timeout) {\n  var free = true;\n  return function () {\n    if (free) {\n      fn.apply(this, arguments);\n      free = false;\n      setTimeout(() => {\n        free = true;\n      }, timeout);\n    }\n  };\n}\n", "/*\nBar chart\n*/\nimport * as d3 from \"d3\";\n\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { maxLabelSize, filterTicks } from \"./ticks\";\nimport { makeDateFormatter } from \"./timeseries\";\nimport { throttle } from \"./throttle\";\n\nexport { parse3dArray, parseTimeSeries3dArray };\n\nexport class BarChart extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Bar charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n    // Default config\n    this.config = {\n      SCREEN_HEIGHT_PERCENT: 0.5,\n      BAND_PAD: 0.2,\n      BAR_STROKE_WIDTH: 1.0,\n      DURATION_MS: 500,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      Y_AXIS_RIGHT: false,\n      COLORS: d3.schemeCategory10, // TODO There's no way to change the default yet\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    // Items can be dynamically hidden from the chart\n    this.hidden = new d3.InternSet();\n\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Config chained methods */\n  bandPadding(value) {\n    this.config.BAND_PAD = value;\n    return this;\n  }\n\n  barOutline(value) {\n    this.config.BAR_STROKE_WIDTH = value;\n    return this;\n  }\n\n  noBarOutline() {\n    return this.barOutline(0.0);\n  }\n  /* End config chained methods */\n\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        return item && item.y ? item.y : 0;\n      })(indexed);\n\n    // Largest items are returned first, since the stack areas are all drawn from zero\n    return stack.reverse();\n  }\n\n  get stack() {\n    // Only visible data - hidden items are all zero\n    return this.getStack(this.visibleData);\n  }\n\n  get fullStack() {\n    // All data\n    return this.getStack(this.data);\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.Z.slice().reverse(), (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get visibleData() {\n    // TODO memoization\n    // Set hidden values to zero\n    return d3.map(this.data, (d) =>\n      this.hidden.has(d.z) ? { x: d.x, y: 0, z: d.z } : d,\n    );\n  }\n\n  get xDomain() {\n    // By default, don't re-calculate the x-axis\n    // Return all unique x values\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.x)));\n  }\n\n  get yDomain() {\n    // Always show the full y Axis\n    return [0, d3.max(this.fullStack[0], (d) => d[1])];\n  }\n\n  get xScale() {\n    return d3\n      .scaleBand()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth])\n      .padding(this.config.BAND_PAD)\n      .align(0.1);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0])\n      .nice();\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(4).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    if (this.config.Y_AXIS_RIGHT) {\n      g.call(d3.axisRight(y).tickSize(0).tickFormat(this.yFormat));\n    } else {\n      g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n    }\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"));\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced, but we still need room for the x-scale tick labels\n      this.layout.pad.left = 15;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(selector, this.config);\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    this.x = this.xScale;\n    this.y = this.yScale;\n\n    // Start with the SVG visible - this can be set to 0 for \"fade in\"\n    this.svg.attr(\"opacity\", 1.0);\n\n    // Create a clip path to hide any overflow content\n    this.svg\n      .append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", \"inner-clip-path\")\n      .append(\"rect\")\n      .attr(\"width\", this.layout.width)\n      .attr(\"height\", this.layout.height);\n\n    this.svg.attr(\"clip-path\", \"url(#inner-clip-path)\");\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    let yTransform = `translate(${this.layout.pad.left - this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    if (this.config.Y_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.pad.left + this.layout.innerWidth + this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    }\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\"transform\", yTransform);\n\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    const gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    // Set initial state\n    this.gx.call(this.xAxis.bind(this), this.x).attr(\"opacity\", 1.0);\n    this.gy.call(this.yAxis.bind(this), this.y);\n    this.gGrid.call(this.grid.bind(this), this.x, this.y);\n\n    this.groups = gInner\n      .append(\"g\")\n      .selectAll()\n      .data(this.stack)\n      .join(\"g\")\n      .attr(\"fill\", (d) => this.colors(d.key))\n      .attr(\"class\", (d) => className(d.key))\n      .attr(\"opacity\", 1.0);\n\n    this.bars = this.groups\n      .selectAll(\"rect\")\n      .data((D) => D)\n      .join(\"rect\")\n      .attr(\"stroke-width\", this.config.BAR_STROKE_WIDTH)\n      .attr(\"x\", (d, i) => this.x(d.data[0]))\n      .attr(\"y\", (d) => this.layout.innerHeight)\n      .attr(\"height\", (d) => 0)\n      .attr(\"width\", this.x.bandwidth());\n\n    this.update(this.x, this.y);\n  }\n\n  update(x, y) {\n    this.groups.data(this.stack);\n    this.bars\n      .data((D) => D)\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"stroke-width\", this.config.BAR_STROKE_WIDTH)\n      .attr(\"x\", (d, i) => this.x(d.data[0]))\n      .attr(\"y\", (d) => this.y(d[1]))\n      .attr(\"height\", (d) => this.y(d[0]) - this.y(d[1]));\n    // .attr(\"width\", this.x.bandwidth());\n  }\n\n  noHighlight() {\n    this.groups.attr(\"opacity\", 1.0);\n  }\n\n  highlight(z) {\n    this.groups.attr(\"opacity\", (d) =>\n      d.key === z ? 1.0 : this.config.BACKGROUND_OPACITY,\n    );\n  }\n\n  onEvent(move, leave) {\n    const pointermove = (evt, d) => {\n      let [xm, ym] = d3.pointer(evt);\n\n      // TODO Is this really the best way to get the data?\n      const x = d.data[0];\n      const y = d[1] - d[0];\n      const z = d3.select(evt.srcElement.parentNode).data()[0].key;\n\n      // Data the will provided to the callback\n      const data = {\n        x: x,\n        y: y,\n        z: z,\n        dx: xm + this.layout.pad.left,\n        dy: ym + this.layout.pad.top,\n      };\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt, d) => {\n      if (leave) {\n        leave.call(this, d.key);\n      }\n    };\n\n    this.bars\n      .on(\"pointermove\", throttle(pointermove, 20.83)) // 48 fps\n      .on(\"pointerleave\", pointerleave);\n  }\n\n  toggle() {\n    this.update(this.x, this.y);\n  }\n}\n\nexport function Bar(data, parser) {\n  return new BarChart(data, parser);\n}\n\nexport class TimeSeriesBarChart extends BarChart {\n  constructor(data, parser) {\n    super(data, parser);\n    this.xLabelWidth = 10;\n  }\n\n  // TODO How to better integrate with xFormat?\n  makeDateFormatter() {\n    return makeDateFormatter();\n  }\n\n  // TODO Declaring an xFormat getter doesn't override the xFormat attribute?\n  get xFormat() {\n    return makeDateFormatter();\n  }\n\n  get xValues() {\n    return filterTicks(this.xDomain, this.layout, this.xLabelWidth);\n  }\n\n  xAxis(g, x) {\n    g.call(\n      d3\n        .axisBottom(x)\n        .tickSize(4)\n        .tickValues(this.xValues)\n        .tickFormat(this.makeDateFormatter()),\n    );\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.makeDateFormatter(),\n      \"x axis\",\n    );\n    this.xLabelWidth = xLabelWidth;\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced, but we still need room for the x-scale tick labels\n      this.layout.pad.left = 15;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  sortData(data) {\n    data.sort((a, b) => a.x - b.x);\n    return data;\n  }\n\n  parseData(data, parser) {\n    // Sort timeseries data in ascending order\n    return this.sortData(super.parseData(data, parser));\n  }\n}\n\nexport function TimeSeriesBar(data, parser) {\n  return new TimeSeriesBarChart(data, parser);\n}\n\nexport class TimeSeriesBarSharesChart extends TimeSeriesBarChart {\n  yFormat = d3.format(\".0%\");\n\n  constructor(data, parser) {\n    super(data, parser);\n\n    // Determine the total per x\n    this.totals = d3.rollup(\n      this.data,\n      (v) => d3.sum(v, (d) => d.y),\n      (d) => d.x,\n    );\n  }\n\n  // Use the stack to calculate shares\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        const total = this.totals.get(item.x);\n        return item && item.y && total ? item.y / total : 0;\n      })(indexed);\n\n    // Largest items are returned first, since the stack are all drawn from zero\n    return stack.reverse();\n  }\n}\n\nexport function TimeSeriesBarShares(data, parser) {\n  return new TimeSeriesBarSharesChart(data, parser);\n}\n", "import * as d3 from \"d3\";\n\nexport const month = d3.utcFormat(\"%b\");\nexport const monthDay = d3.utcFormat(\"%b %-d\");\nexport const monthYear = d3.utcFormat(\"%b %Y\");\nexport const monthDayYear = d3.utcFormat(\"%b %-d, %Y\");\nexport const fullMonthDayYear = d3.utcFormat(\"%B %-d, %Y\");\n\nexport function makeDateFormatter() {\n  let lastYear = null;\n  return function (d) {\n    const year = d.getUTCFullYear();\n    if (lastYear !== year) {\n      lastYear = year;\n      return monthDayYear(d);\n    }\n    return monthDay(d);\n  };\n}\n\nexport function makeMonthlyDateFormatter() {\n  let lastYear = null;\n  return function (d) {\n    const year = d.getUTCFullYear();\n    if (lastYear !== year) {\n      lastYear = year;\n      return monthYear(d);\n    }\n    return month(d);\n  };\n}\n\nexport function quarter(d) {\n  // Format a Date as a quarter and year\n  const q = parseInt(d.getUTCMonth() / 3) + 1;\n  return `${q}Q ${d.getUTCFullYear()}`;\n}\n\nexport const year = (d) => d.getUTCFullYear();\n\nexport function quarterToIso(value) {\n  // Convert a quarter in the format (q)Q(yyyy) - e.g. 1Q2024 - to an ISO date\n  value = String(value).replace(\" \", \"\");\n  let year = \"\";\n  if (value.length === 4) {\n    year = `20${value.substring(2)}`;\n  } else if (value.length === 6) {\n    year = value.substring(2);\n  }\n  if (!year) return null;\n  let q = parseInt(value.substring(0, 1));\n  let month = `${q * 3}`.padStart(2, \"0\");\n  let day = [\"\", \"31\", \"30\", \"30\", \"31\"][q];\n  return d3.isoParse(`${year}-${month}-${day}`);\n}\n\nexport function yearToIso(value) {\n  // Convert a year to an ISO date\n  if (value.length !== 4) return null;\n  const year = parseInt(value);\n  return d3.isoParse(`${year}-01-01`);\n}\n", "import * as d3 from \"d3\";\n\nimport { Chart } from \"./chart\";\nimport { volume } from \"./formats\";\nimport { layoutSVG } from \"./layout\";\nimport { parseArrayOHLCV, parseVerboseOHLCV } from \"./parsers\";\nimport { throttle } from \"./throttle\";\nimport { maxLabelSize, filterTicks } from \"./ticks\";\nimport { makeDateFormatter } from \"./timeseries\";\n\nexport { parseArrayOHLCV, parseVerboseOHLCV };\n\nfunction signOf(d) {\n  // TODO Assumes both open and close are defined\n  return 1 + Math.sign(d.o - d.c);\n}\n\nconst classes = [\"up\", \"even\", \"down\"];\n\nfunction deltaClass(d) {\n  // Return's a class depending on the day's delta\n  return classes[signOf(d)];\n}\n\nfunction zoomRange(domain, width, start, end) {\n  // Return the range extent needed to zoom to the start and end indices of the domain\n  let w = end - start + 1;\n  let ratio = 1;\n  if (w < domain.length) {\n    ratio = domain.length / w;\n  }\n  const zoomWidth = width * ratio;\n  const offsetX = (start / domain.length) * zoomWidth;\n  return [0 - offsetX, zoomWidth - offsetX];\n}\n\nfunction extentData(data, start = 0, end) {\n  // Calculate the extent of the price data, optionally with a slice of the data\n  if (end) {\n    data = data.slice(start, end + 1);\n  }\n  const minY = d3.min(d3.map(data, (d) => d.l));\n  return [minY, d3.max(d3.map(data, (d) => d.h))];\n}\n\nfunction invertBand(scale, x) {\n  const domain = scale.domain();\n  const padOuter = scale(domain[0]);\n  const eachBand = scale.step();\n  const index = Math.floor((x - padOuter) / eachBand);\n  return Math.max(0, Math.min(index, domain.length - 1));\n}\n\nexport class CandlestickChart extends Chart {\n  // Allow a custom formatting of prices, setting null will use default formats\n  priceFormat = d3.format(\",~f\");\n\n  // CandlestickChart expects data in the format [{x, o, h, l, c, v}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      VOLUME_RATIO: 0.0,\n      LOG_Y: false, // We need to know which scale is used for proper tick formats\n      SCREEN_HEIGHT_PERCENT: 0.5,\n      BAND_PAD: 0.1,\n      DURATION_MS: 500,\n      PRICE_AXIS_RIGHT: false,\n      VOLUME_AXIS_RIGHT: true,\n      HIDE_VOLUME_AXIS: false,\n      VOLUME_TICK_COUNT: 1,\n      RESCALE_Y: true,\n\n      // Additional layout padding\n      // TODO Specify an additional layout?\n      MARGIN_RIGHT: 10,\n      MARGIN_LEFT: 10,\n      MARGIN_LABEL: 10,\n      MARGIN_AXES: 5,\n      MARGIN_TICK: 2,\n    };\n\n    // Get data in a {x, o, h, l, c, v} format\n    // TODO Warn if data wasn't parsed\n    this.data = d3.map(data, parser);\n\n    // Also save the X axis, since it is used for filtering tick labels\n    this.X = d3.map(this.data, (d) => d.x);\n\n    // Zoom works by setting the start and end indices\n    // By default, all data is shown\n    this.start = 0;\n    this.end = this.data.length - 1;\n  }\n\n  /* Config chained methods */\n  doNotRescaleY() {\n    // Do not rescale the Y axis on zoom\n    this.config.RESCALE_Y = false;\n    return this;\n  }\n\n  bandPadding(value) {\n    this.config.BAND_PAD = value;\n    return this;\n  }\n\n  priceAxisRight() {\n    // The price axis ticks and labels will be shown on the right of the chart\n    this.config.PRICE_AXIS_RIGHT = true;\n    return this;\n  }\n\n  showVolume(ratio = 0.1) {\n    // TODO Allow to be called dynamically?\n    this.config.VOLUME_RATIO = ratio;\n    return this;\n  }\n\n  hideVolume() {\n    // TODO Allow to be called dynamically?\n    return this.showVolume(0.0);\n  }\n\n  hideVolumeAxis() {\n    // The volume chart will still be shown, but without a label\n    this.config.HIDE_VOLUME_AXIS = true;\n    return this;\n  }\n\n  volumeTickCount(value = 1) {\n    // Number of volume axis ticks that should be shown\n    this.config.VOLUME_TICK_COUNT = value;\n    return this;\n  }\n\n  defaultLog() {\n    this.config.LOG_Y = true;\n    return this;\n  }\n\n  defaultLinear() {\n    this.config.LOG_Y = false;\n    return this;\n  }\n  /* End config chained methods */\n\n  get volumeAxesIsVisible() {\n    return Boolean(this.config.VOLUME_RATIO) && !this.config.HIDE_VOLUME_AXIS;\n  }\n\n  get volumeAxesVisibility() {\n    return this.volumeAxesIsVisible ? \"visible\" : \"hidden\";\n  }\n\n  get priceTickFormat() {\n    // Linear axes can use the priceFormat directly, but log axes need additional config\n    if (this.config.LOG_Y) {\n      const numTicks = d3.max([this.scaleLinear.ticks().length, 2]);\n      return this.scaleLog.tickFormat(numTicks, this.priceFormat);\n    } else {\n      return this.priceFormat;\n    }\n  }\n\n  get priceAxisIndex() {\n    if (this.config.PRICE_AXIS_RIGHT) {\n      return d3.axisRight(this.scaleY).tickFormat(this.priceTickFormat);\n    }\n    return d3.axisLeft(this.scaleY).tickFormat(this.priceTickFormat);\n  }\n\n  get gridWidth() {\n    return -this.layout.innerWidth - this.config.MARGIN_AXES;\n  }\n\n  get wickThickness() {\n    // Wick thickness should at least one pixel, but no greater than 1% of the band\n    return d3.max([this.scaleX.bandwidth() * 0.01, 1.0]);\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(selector, this.config);\n\n    // The price and volume portions of the chart will share an x-axis\n    const volumeHeight = this.layout.innerHeight * this.config.VOLUME_RATIO;\n    const priceHeight = this.layout.innerHeight - volumeHeight;\n\n    const maxVolume = d3.max(d3.map(this.data, (d) => d.v));\n\n    this.scaleVolume = d3\n      .scaleLinear()\n      .domain([0, maxVolume])\n      .range([volumeHeight, 0])\n      .clamp(true)\n      .nice();\n\n    // Right pad the volume ticks\n    if (this.volumeAxesIsVisible) {\n      const [volWidth, volHeight] = maxLabelSize(\n        this.svg,\n        this.layout,\n        this.scaleVolume.copy(),\n        volume,\n        \"v axis\",\n      );\n      this.layout.pad.right = volWidth + this.config.MARGIN_RIGHT;\n    }\n\n    let domainY = extentData(this.data);\n    const minY = domainY[0];\n    const rangeY = [priceHeight, 0];\n\n    // Axes\n    this.scaleLinear = d3\n      .scaleLinear()\n      .domain(domainY)\n      .range(rangeY)\n      .clamp(true);\n    this.scaleLog = d3.scaleLog().domain(domainY).range(rangeY).clamp(true);\n\n    // Get the max tick label width for the y-axis on both linear and log scales\n    const [logWidth, logHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.scaleLog.copy(),\n      this.priceFormat,\n      \"y axis\",\n    );\n    const [linearWidth, linearHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.scaleLinear.copy(),\n      this.priceFormat,\n      \"y axis\",\n    );\n    const labelWidthY = d3.max([logWidth, linearWidth]);\n\n    // Left pad the the y-axis labels\n    // TODO Option for additional padding\n    if (this.config.PRICE_AXIS_RIGHT) {\n      this.layout.pad.left = this.config.MARGIN_LEFT;\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        labelWidthY + this.config.MARGIN_RIGHT,\n      ]);\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        labelWidthY + this.config.MARGIN_LEFT,\n      ]);\n    }\n\n    // Create a clip path for the inner data element to hide any overflow content\n    this.svg\n      .append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", \"inner-clip-path\")\n      .append(\"rect\")\n      .attr(\"width\", this.layout.innerWidth)\n      .attr(\"height\", this.layout.innerHeight);\n\n    // Set the inner display\n    this.inner = this.svg\n      .append(\"g\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    this.scaleX = d3\n      .scaleBand(this.X, [0, this.layout.innerWidth])\n      .paddingInner(this.config.BAND_PAD)\n      .align(0.5);\n    // NOTE do not use round\n\n    // NOTE The date formatter needs to be created because it uses a\n    // closure to determine a new year\n    let dates = makeDateFormatter();\n\n    // Get the max tick label width for the x-axis\n    const [labelWidthX, labelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.scaleX.copy(),\n      dates,\n      \"x axis\",\n    );\n    this.labelWidthX = labelWidthX + this.config.MARGIN_LABEL;\n    const filteredX = filterTicks(this.X, this.layout, this.labelWidthX);\n\n    // Reset the date formatter\n    dates = makeDateFormatter();\n\n    // Set the zero state\n    this.scaleY = this.config.LOG_Y ? this.scaleLog : this.scaleLinear;\n    const axisY = this.priceAxisIndex;\n\n    this.axisX = d3\n      .axisBottom(this.scaleX)\n      .tickValues(filteredX)\n      .tickFormat(dates)\n      .tickSize(3);\n\n    let yTransform = \"transform(0,0)\";\n    if (this.config.PRICE_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.innerWidth + this.config.MARGIN_AXES},0)`;\n    }\n\n    this.gPrice = this.inner\n      .append(\"g\")\n      .attr(\"transform\", yTransform)\n      .attr(\"class\", \"y axis\")\n      .call(axisY.tickSize(0));\n\n    this.grid = this.inner\n      .append(\"g\")\n      .attr(\"transform\", yTransform)\n      .attr(\"class\", \"grid\")\n      .call(axisY.tickSize(this.gridWidth));\n\n    const bandPad = (this.scaleX.bandwidth() * this.config.BAND_PAD) / 2;\n\n    this.gx = this.inner\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${bandPad + 0.5},${this.layout.innerHeight + this.config.MARGIN_TICK})`,\n      )\n      .call(this.axisX);\n\n    this.price = this.inner.append(\"g\").attr(\"class\", \"price\");\n\n    this.candles = this.price\n      .append(\"g\")\n      .attr(\"clip-path\", \"url(#inner-clip-path)\")\n      .attr(\"stroke-linecap\", \"butt\") // NOTE using 'square' distorts size\n      .attr(\"stroke\", \"currentColor\")\n      .selectAll(\"g\")\n      .data(this.data)\n      .join(\"g\")\n      .attr(\"class\", deltaClass)\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.step() / 2.0},0)`,\n      );\n\n    this.wicks = this.candles\n      .append(\"line\")\n      .attr(\"stroke-width\", this.wickThickness)\n      .attr(\"class\", \"wick\")\n      .attr(\"y1\", this.scaleY(minY))\n      .attr(\"y2\", this.scaleY(minY));\n\n    this.bars = this.candles\n      .append(\"line\")\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"class\", \"bar\")\n      .attr(\"y1\", this.scaleY(minY))\n      .attr(\"y2\", this.scaleY(minY));\n\n    // Volume elements are always rendered even if their height is zero\n    this.axisVolume = d3\n      .axisRight(this.scaleVolume)\n      .ticks(this.config.VOLUME_TICK_COUNT)\n      .tickFormat(volume)\n      .tickSize(3);\n\n    this.volume = this.inner\n      .append(\"g\")\n      .attr(\"class\", \"volume\")\n      .attr(\n        \"transform\",\n        `translate(0,${this.layout.innerHeight - volumeHeight})`,\n      );\n\n    this.gVolume = this.volume\n      .append(\"g\")\n      .attr(\"class\", \"v axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.innerWidth + this.config.MARGIN_TICK},0)`,\n      )\n      .call(this.axisVolume)\n      .attr(\"visibility\", this.volumeAxesVisibility);\n\n    this.volumeSlots = this.volume\n      .append(\"g\")\n      .attr(\"clip-path\", \"url(#inner-clip-path)\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-linecap\", \"butt\") // NOTE using 'square' distorts size\n      .selectAll(\"g\")\n      .data(this.data)\n      .join(\"g\")\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.step() / 2.0},0)`,\n      );\n\n    this.volumeBars = this.volumeSlots\n      .append(\"line\")\n      .attr(\"y1\", this.scaleVolume(0))\n      .attr(\"y2\", this.scaleVolume(0))\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"class\", deltaClass);\n\n    // Brush for zoom\n    this.brush = d3\n      .brushX()\n      .extent([\n        [0, 0],\n        [this.layout.innerWidth, this.layout.innerHeight],\n      ])\n      .on(\"end\", this.zoom.bind(this));\n\n    this.gBrush = this.inner\n      .append(\"g\")\n      .attr(\"class\", \"brush\")\n      .call(this.brush.bind(this));\n\n    // Optional spotlight of a bar\n    // Don't call the class \"tooltip\" - that interferes with Bootstrap\n    this.spotlightBar = this.inner\n      .append(\"g\")\n      .lower() // The spotlight should always be the lowest layer of the SVG\n      .attr(\"class\", \"spotlight\")\n      .append(\"rect\")\n      .style(\"display\", \"none\")\n      .style(\"pointer-events\", \"none\");\n\n    // Set the initial prices with the default axes\n    this.update();\n  }\n\n  update() {\n    // Update the chart to start and end on the given x-axis indices\n    // The y-axis will also be updated to the min and max of the data for the given xs\n    const zRange = zoomRange(\n      this.scaleX.domain(),\n      this.layout.innerWidth,\n      this.start,\n      this.end,\n    );\n\n    // Do not update the domain - just the range\n    this.scaleX.range(zRange);\n\n    // Update the axisY according to the new min and max of the data\n    if (this.config.RESCALE_Y) {\n      let domainY = extentData(this.data, this.start, this.end);\n      this.scaleLinear.domain(domainY);\n      this.scaleLog.domain(domainY); // TODO .nice() can be called here\n    }\n\n    this.scaleY = this.config.LOG_Y ? this.scaleLog : this.scaleLinear;\n    const axisY = this.priceAxisIndex;\n\n    // Re-filter the X-axis date labels\n    const filteredX = filterTicks(\n      this.X.slice(this.start, this.end + 1),\n      this.layout,\n      this.labelWidthX,\n    );\n\n    // Reset the date formatter\n    const dates = makeDateFormatter();\n    this.axisX.tickValues(filteredX).tickFormat(dates);\n\n    // Update the x-axis\n    const bandPad = (this.scaleX.bandwidth() * this.config.BAND_PAD) / 2;\n    this.gx\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\n        \"transform\",\n        `translate(${bandPad + 0.5},${this.layout.innerHeight + this.config.MARGIN_TICK})`,\n      )\n      .call(this.axisX);\n\n    // Update the y-axis\n    this.gPrice\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(axisY.tickSize(0));\n\n    // Update the grid\n    this.grid\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(axisY.tickFormat(\"\").tickSize(this.gridWidth));\n\n    // Update the candles\n    this.candles\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.step() / 2.0},0)`,\n      );\n\n    this.bars\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"y1\", (d) => this.scaleY(d.o))\n      .attr(\"y2\", (d) => this.scaleY(d.c));\n\n    this.wicks\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"stroke-width\", this.wickThickness)\n      .attr(\"y1\", (d) => this.scaleY(d.l))\n      .attr(\"y2\", (d) => this.scaleY(d.h));\n\n    // Hide the spotlight on update - it will reactivate on next hover\n    this.noSpotlight();\n\n    // Update the spotlight width\n    this.spotlightBar\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"width\", this.scaleX.step());\n\n    // Update the volume\n    this.volumeSlots\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.step() / 2.0},0)`,\n      );\n\n    this.volumeBars\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"y2\", (d) => this.scaleVolume(d.v || 0));\n  }\n\n  zoom({ selection }) {\n    if (!selection) return;\n    // Get the closest indices to the selection\n    const [x0, x1] = selection;\n    [this.start, this.end] = [\n      invertBand(this.scaleX, x0),\n      invertBand(this.scaleX, x1),\n    ];\n    this.update();\n\n    // Reset the brush\n    this.gBrush.call(this.brush.move, null);\n  }\n\n  reset() {\n    this.start = 0;\n    this.end = this.data.length - 1;\n    this.update();\n  }\n\n  useLog() {\n    this.config.LOG_Y = true;\n    this.update();\n  }\n\n  useLinear() {\n    this.config.LOG_Y = false;\n    this.update();\n  }\n\n  spotlight(index) {\n    // TODO We only need to pad if width is set to bandwidth instead of step\n    // const pad = this.scaleX.bandwidth() * this.scaleX.paddingInner() * 0.5;\n    this.spotlightBar\n      .attr(\"x\", this.scaleX(this.data[index].x))\n      .attr(\"width\", this.scaleX.step())\n      .attr(\"y\", 0)\n      .attr(\"height\", this.layout.innerHeight)\n      .style(\"display\", \"block\");\n  }\n\n  noSpotlight() {\n    this.spotlightBar.style(\"display\", \"none\");\n  }\n\n  onEvent(move, leave) {\n    // Enable events for the chart. On move, determine which band is being\n    // hovered over and send an object of its OHLCV data to the move callback.\n    // The leave callback is triggered when the pointer leaves the SVG elem.\n    let prevIndex = null;\n\n    const pointermove = (evt) => {\n      const [xm] = d3.pointer(evt);\n      const index = invertBand(this.scaleX, xm - this.layout.pad.left);\n\n      // Only trigger the callback when the index changes\n      if (prevIndex && prevIndex == index) {\n        return;\n      }\n\n      prevIndex = index;\n\n      // Include the index's OHLCV data and a change from the last close\n      let data = structuredClone(this.data[index]);\n      data.index = index;\n\n      if (index > 0) {\n        const prev = this.data[index - 1];\n        if (prev && prev.c) {\n          data.prev = prev.c;\n          data.delta = data.c - prev.c;\n          data.percent = data.delta / prev.c;\n        }\n      }\n\n      if (move) {\n        move.call(this, data);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      prevIndex = null;\n      if (leave) {\n        leave.call(this);\n      }\n    };\n\n    this.svg\n      .on(\"pointermove\", throttle(pointermove, 20.83)) // 48 fps\n      .on(\"pointerleave\", pointerleave);\n  }\n\n  // TODO method to append a data point\n  append() {}\n}\n\nexport function OHLC(data, parser) {\n  return new CandlestickChart(data, parser);\n}\n\nexport function OHLCV(data, parser) {\n  return new CandlestickChart(data, parser).showVolume();\n}\n", "import * as d3 from \"d3\";\n\nexport const percent = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 0,\n  maximumFractionDigits: 2,\n}).format;\n\nexport const percentChange = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n  signDisplay: \"exceptZero\",\n}).format;\n\nexport const magnitude = new Intl.NumberFormat(\"en-US\", {\n  notation: \"compact\",\n  compactDisplay: \"short\",\n  minimumFractionDigits: 1,\n  maximumFractionDigits: 2,\n}).format;\n\nexport const units = d3.format(\",.0f\");\n\nexport const volume = function (value) {\n  if (!value) return; // Never show 0\n  if (value >= 1e9) return `${value / 1e9}B`; // Billions\n  if (value >= 1e6) return `${value / 1e6}M`; // Millions\n  return units(value);\n};\n", "/*\nLine chart\n*/\nimport * as d3 from \"d3\";\n\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { maxLabelSize } from \"./ticks\";\nimport { throttle } from \"./throttle\";\n\nexport { parse3dArray, parseTimeSeries3dArray };\n\nfunction getLength(elem) {\n  // Not all DOMs support getTotalLength\n  return elem.getTotalLength ? elem.getTotalLength() : null;\n}\n\nexport class LineChart extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Line charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      SCREEN_HEIGHT_PERCENT: 0.5,\n      DURATION_MS: 500,\n      Y_AXIS_RIGHT: false,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      HIGHLIGHT_STROKE_WIDTH: 2.0, // Width when highlighted\n      STROKE_WIDTH: 1.5, // Width when not highlighted\n      DOT_RADIUS: 3.0, // Radius of the dot\n      HIDE_EMPTY_CHART: false,\n      COLORS: d3.schemeCategory10, // TODO There's no way to change the default yet\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.Z, (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get zVisible() {\n    const visible = new d3.InternSet(this.Z);\n    this.hidden.forEach((z) => visible.delete(z));\n    return Array.from(visible);\n  }\n\n  get visibleData() {\n    // TODO memoization\n    return d3.filter(this.data, (d) => !this.hidden.has(d.z));\n  }\n\n  get empty() {\n    // Returns True if there are no visible items on the chart\n    return this.zVisible.length === 0;\n  }\n\n  get xDomain() {\n    // By default, don't re-calculate the x-axis\n    return d3.extent(d3.map(this.data, (d) => d.x));\n  }\n\n  get yDomain() {\n    // TODO memoization\n    if (this.visibleData.length) {\n      return d3.extent(d3.map(this.visibleData, (d) => d.y));\n    } else {\n      return d3.extent(d3.map(this.data, (d) => d.y));\n    }\n  }\n\n  get xScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0]);\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(3).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    if (this.config.Y_AXIS_RIGHT) {\n      g.call(d3.axisRight(y).tickSize(0).tickFormat(this.yFormat));\n    } else {\n      g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n    }\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    // Another option for \"zero state\" is to set the tick size to zero\n    // const tickSize = this.empty ? 0 : -this.layout.innerWidth;\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"));\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced\n      this.layout.pad.left = 5;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(selector, this.config);\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    this.x = this.xScale;\n    this.y = this.yScale;\n\n    // Start with the SVG visible - this can be set to 0 for \"fade in\"\n    this.svg.attr(\"opacity\", 1.0);\n\n    // Create a clip path to hide any overflow content\n    this.svg\n      .append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", \"inner-clip-path\")\n      .append(\"rect\")\n      .attr(\"width\", this.layout.width)\n      .attr(\"height\", this.layout.height);\n\n    this.svg.attr(\"clip-path\", \"url(#inner-clip-path)\");\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    let yTransform = `translate(${this.layout.pad.left - this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    if (this.config.Y_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.pad.left + this.layout.innerWidth + this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    }\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\"transform\", yTransform);\n\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    const gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    const grouping = d3.group(this.data, (d) => d.z);\n\n    this.paths = gInner\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH)\n      .selectAll(\"path\")\n      .data(grouping)\n      .join(\"path\");\n\n    // Dot - shows nearest point during pointer events\n    this.dot = gInner.append(\"g\").attr(\"class\", \"dot\").style(\"display\", \"none\");\n    this.circle = this.dot.append(\"circle\").attr(\"r\", this.config.DOT_RADIUS);\n\n    // The initial line drawing animation relies on manipulating stroke attributes,\n    // which can change whenever we redraw lines, so we'll only do the draw animation\n    // once and all subsequent updates will just use a solid stroke\n    this.previousUpdate = false;\n\n    // Visibility and opacity will be changed when the chart is in a \"zero state\"\n    const isEmpty = this.empty;\n\n    // Set initial state\n    this.gx.call(this.xAxis.bind(this), this.x).attr(\"opacity\", 1.0);\n\n    this.gy\n      .call(this.yAxis.bind(this), this.y)\n      .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n\n    this.gGrid.call(this.grid.bind(this), this.x, this.y);\n\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => this.x(d.x))\n      .y((d) => this.y(d.y));\n\n    this.paths\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"stroke\", ([z]) => this.colors(z))\n      .attr(\"class\", ([z]) => className(z))\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n\n    const lengths = d3.map(this.paths, (elem) => getLength(elem));\n\n    this.paths\n      .attr(\"stroke-dasharray\", (d, i) =>\n        this.getStrokeDasharray(d, i, lengths),\n      )\n      .attr(\"stroke-dashoffset\", (d, i) =>\n        this.getStrokeDashOffset(d, i, lengths),\n      );\n\n    this.update(this.x, this.y);\n  }\n\n  getStrokeDasharray(d, i, lengths, previousUpdate) {\n    // By default, the dasharray performs an opening animation\n    if (previousUpdate) return \"1 0\";\n    return lengths[i] ? `${lengths[i]} ${lengths[i]}` : null;\n  }\n\n  getStrokeDashOffset(d, i, lengths) {\n    return lengths[i] || 0;\n  }\n\n  update(x, y) {\n    this.hideDot();\n\n    const isEmpty = this.empty;\n\n    // Option to hide the chart if there's no visible data\n    if (this.config.HIDE_EMPTY_CHART) {\n      this.svg\n        .transition()\n        .duration(this.config.DURATION_MS)\n        .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n    }\n\n    // Re-draw the chart with the new x and y scales\n    // NOTE: with current setup, x-axis doesn't need to be updated\n    this.gx\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(this.xAxis.bind(this), x);\n\n    this.gy\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(this.yAxis.bind(this), y)\n      .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n\n    // Grid lines have a hardcoded opacity 1, so we need to use visibility to hide them\n    this.gGrid\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"visibility\", isEmpty ? \"hidden\" : \"visible\")\n      .call(this.grid.bind(this), x, y);\n\n    // Plot the line\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => x(d.x))\n      .y((d) => y(d.y));\n\n    this.paths\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"stroke-dashoffset\", 0)\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n\n    if (this.previousUpdate) {\n      // TODO How to support both an animation and custom styles needs more thought\n      this.paths.attr(\"stroke-dasharray\", (d, i) =>\n        this.getStrokeDasharray(d, i, [], this.previousUpdate),\n      );\n    }\n    this.previousUpdate = true;\n  }\n\n  placeDot(index) {\n    // Place a dot at the given index\n    const d = this.data[index];\n    this.dot\n      .style(\"display\", null)\n      .attr(\"transform\", `translate(${this.x(d.x)},${this.y(d.y)})`);\n    this.circle.attr(\"fill\", this.colors(d.z));\n  }\n\n  hideDot() {\n    this.dot.style(\"display\", \"none\");\n  }\n\n  noHighlight() {\n    // Reset all lines to default\n    this.paths\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0))\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH);\n  }\n\n  highlight(z) {\n    // Hide paths that aren't the currently selected path\n    this.paths\n      .attr(\"opacity\", ([elem]) => {\n        if (this.hidden.has(elem)) return 0;\n        return elem === z ? 1.0 : this.config.BACKGROUND_OPACITY;\n      })\n      .attr(\"stroke-width\", ([elem]) =>\n        elem === z\n          ? this.config.HIGHLIGHT_STROKE_WIDTH\n          : this.config.STROKE_WIDTH,\n      );\n  }\n\n  onEvent(move, leave) {\n    let prevIndex = null;\n\n    // Determine the closest point to the cursor\n    const pointermove = (evt) => {\n      let [xm, ym] = d3.pointer(evt);\n      // X and y scales use the inner element, which is padded\n      xm -= this.layout.pad.left;\n      ym -= this.layout.pad.top;\n      const points = d3.map(this.data, (d) => {\n        if (this.hidden.has(d.z)) return null;\n        return Math.hypot(this.x(d.x) - xm, this.y(d.y) - ym);\n      });\n\n      const index = d3.leastIndex(points);\n      if (index === -1 || points[index] === null) return;\n\n      // Exit early if no point was found\n      if (typeof index === \"undefined\") return;\n\n      // Only trigger the callback when the index changes\n      if (prevIndex && prevIndex == index) return;\n\n      this.placeDot(index);\n\n      const d = this.data[index];\n\n      // Data that will be provided to the callback\n      const data = {\n        x: d.x,\n        y: d.y,\n        z: d.z,\n        dx: this.x(d.x) + this.layout.pad.left,\n        dy: this.y(d.y) + this.layout.pad.top,\n      };\n\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      this.hideDot();\n      if (leave) {\n        leave.call(this, evt);\n      }\n    };\n\n    this.svg\n      .on(\"pointermove\", throttle(pointermove, 20.83)) // 48 fps\n      .on(\"pointerleave\", pointerleave)\n      .on(\"touchstart\", (evt) => {\n        pointermove(evt);\n        evt.preventDefault();\n      });\n  }\n\n  toggle() {\n    if (this.visibleData.length) {\n      // Recalculate the y-scale based on the non-hidden items\n      this.y = this.yScale;\n    } else {\n      // Set y-axis to zero\n      // We would need the last y-axis domain in order to prevent tick labels\n      // from changing during this transition\n      this.y = d3\n        .scaleLinear()\n        .domain(this.y.domain())\n        .range([this.layout.innerHeight, this.layout.innerHeight]);\n    }\n    this.update(this.x, this.y);\n  }\n}\n\nexport function Line(data, parser) {\n  return new LineChart(data, parser);\n}\n\nexport class TimeSeriesChart extends LineChart {\n  get xScale() {\n    // Never re-calculate the x-axis\n    return d3\n      .scaleUtc()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  sortData(data) {\n    data.sort((a, b) => a.x - b.x);\n    return data;\n  }\n\n  parseData(data, parser) {\n    // Sort timeseries data in ascending order\n    return this.sortData(super.parseData(data, parser));\n  }\n}\n\nexport function TimeSeries(data, parser) {\n  return new TimeSeriesChart(data, parser);\n}\n", "import * as d3 from \"d3\";\n\nexport function lowerBoundDigits(values, bound = 0.1) {\n  // Determine how many significant digits should be used to represent the lower\n  // bound of values\n  if (!values || !values.length) {\n    return null;\n  }\n  // Only works for positive values\n  const lowerBound = d3.quantile(values, bound);\n  if (lowerBound > 0) {\n    return parseInt(Math.floor(Math.log10(lowerBound)));\n  }\n  return null;\n}\n", "import * as d3 from \"d3\";\n\nexport class Options {\n  constructor(options = {}) {\n    this.ANIMATION_DURATION_MS = 500;\n\n    // Allow either max number of ticks OR spacing\n    this.SCREEN_HEIGHT_FRACTION = 0.65;\n    this.X_TICK_MAX_COUNT = null;\n    this.X_TICK_SPACE = 50; // TODO calculate largest tick space dynamically\n    this.X_TICK_SIZE = 4;\n    this.X_TICK_GUTTER = 3;\n    this.Y_TICK_MAX_COUNT = null;\n    this.Y_TICK_SPACE = 40;\n    this.Y_TICK_SIZE = 0;\n    this.Y_TICK_GUTTER = 5; // Space between tick label and grid\n    this.FONT_SIZE = \"13px\";\n    this.COLORS = d3.schemeCategory10;\n    this.MIN_Y_AT_ZERO = false;\n    this.Y_TICKS_RIGHT = false;\n\n    // OHLC\n    this.BAND_PAD = 0.2; // As a percentage of the band\n    this.VOLUME_OPACITY = 0.6;\n    this.OHLC_COLORS = [\"#1ebc8c\", \"#b2b2b2\", \"#f34d27\"]; // [up, no change, down]\n    this.VOLUME_COLORS = [\"#1ebc8c\", \"#b2b2b2\", \"#f34d27\"]; // [up, no change, down]\n    this.HIDE_VOLUME = false;\n    this.HIDE_VOLUME_TICKS = false;\n\n    // Line\n    this.STROKE_WIDTH = 1.5;\n    this.HIGHLIGHT_STROKE_WIDTH = 2.0;\n    this.BACKGROUND_OPACITY = 0.3; // When another line is highlighted\n    this.DOT_RADIUS = 3.0;\n\n    // Bar\n    this.BAR_STROKE_WIDTH = 0.0;\n\n    // Pie\n    this.INNER_RADIUS = 0.3;\n    this.OUTER_RADIUS = 0.8;\n\n    this.INNER_RADIUS_HOVER = 0.3;\n    this.OUTER_RADIUS_HOVER = 0.9;\n\n    // TODO POINTER MOVE FPS\n    this.EVENT_FPS = 48;\n\n    // Allow user to override any of the above defaults\n    Object.assign(this, options);\n  }\n\n  get eventLatency() {\n    return parseInt(1000 / this.EVENT_FPS);\n  }\n\n  get showVolumeTicks() {\n    return !(this.HIDE_VOLUME || this.HIDE_VOLUME_TICKS);\n  }\n\n  getYTickCount(height) {\n    let count = parseInt(height / this.Y_TICK_SPACE) + 1;\n    if (this.Y_TICK_MAX_COUNT && count > this.Y_TICK_MAX_COUNT) {\n      count = this.Y_TICK_MAX_COUNT;\n    }\n    return count;\n  }\n\n  getXTickCount(width) {\n    let count = parseInt(width / this.X_TICK_SPACE) + 1;\n    if (this.X_TICK_MAX_COUNT && count > this.X_TICK_MAX_COUNT) {\n      count = this.X_TICK_MAX_COUNT;\n    }\n    return count;\n  }\n}\n", "/*\nPie chart (or donut)\n*/\nimport * as d3 from \"d3\";\n\nimport { layoutSVG } from \"./layout\";\n\nexport function parse3dArray(d) {\n  return {\n    x: d[0],\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport function parse2dArray(d) {\n  // For data without an x-axis\n  return {\n    x: null,\n    y: d[0],\n    z: d[1],\n  };\n}\n\nexport function parseTimeSeries3dArray(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport class PieChart {\n  // Pie charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    // Default config\n    this.config = {\n      SCREEN_HEIGHT_PERCENT: 0.5,\n      DURATION_MS: 500,\n      INNER_RADIUS: 0.3,\n      OUTER_RADIUS: 0.8,\n      INNER_RADIUS_HOVER: 0.3,\n      OUTER_RADIUS_HOVER: 0.9,\n      BACKGROUND_OPACITY: 0.5, // Opacity when another slice is highlighted\n      START_ANGLE: 0,\n      END_ANGLE: 2 * Math.PI,\n      INITIAL_CLOSED: false,\n      SKIP_ENTER_ANIMATION: false,\n      COLORS: d3.schemeCategory10, // TODO There's no way to change the default yet\n    };\n\n    this.data = d3.map(data, parser);\n\n    this.X = Array.from(new d3.InternSet(d3.map(this.data, (d) => d.x)));\n    this.Z = Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n\n    // Group data by x - these are the individual data sets that will render the pie\n    this.byX = d3.group(this.data, (d) => d.x);\n\n    this.colors = d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Config chained methods */\n  screenHeightPercent(value) {\n    this.config.SCREEN_HEIGHT_PERCENT = value;\n    return this;\n  }\n\n  animationDuration(value) {\n    this.config.DURATION_MS = value;\n    return this;\n  }\n\n  noAnimation() {\n    return this.animationDuration(0);\n  }\n\n  useDiscreteScheme(scheme) {\n    this.colors = d3.scaleOrdinal().domain(this.Z).range(scheme);\n    return this;\n  }\n\n  useContinuousScheme(scheme, min = 0.0, max = 1.0) {\n    const colors = d3.quantize(\n      (t) => scheme(t * (max - min) + min),\n      this.Z.length,\n    );\n    return this.useDiscreteScheme(colors);\n  }\n\n  radii(inner, outer) {\n    // Set radii\n    this.config.INNER_RADIUS = inner;\n    this.config.OUTER_RADIUS = outer;\n    return this;\n  }\n\n  hoverRadii(inner, outer) {\n    // Set radii on hover\n    this.config.INNER_RADIUS_HOVER = inner;\n    this.config.OUTER_RADIUS_HOVER = outer;\n    return this;\n  }\n\n  angles(start, end) {\n    this.config.START_ANGLE = start;\n    this.config.END_ANGLE = end;\n    return this;\n  }\n\n  renderClosed() {\n    // The initial render of the pie chart will be all zero, aka closed\n    this.config.INITIAL_CLOSED = true;\n    return this;\n  }\n\n  skipEnterAnimation() {\n    this.config.SKIP_ENTER_ANIMATION = true;\n    return this;\n  }\n  /* End config chained methods */\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(new Set(this.Z), (d) => {\n      return { key: d, color: this.color(d) };\n    });\n  }\n\n  get outerRadius() {\n    return this.config.OUTER_RADIUS * (this.layout.innerMinimum / 2);\n  }\n\n  get innerRadius() {\n    return this.config.INNER_RADIUS * (this.layout.innerMinimum / 2);\n  }\n\n  get outerRadiusHover() {\n    return this.config.OUTER_RADIUS_HOVER * (this.layout.innerMinimum / 2);\n  }\n\n  get innerRadiusHover() {\n    return this.config.INNER_RADIUS_HOVER * (this.layout.innerMinimum / 2);\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(selector, this.config);\n\n    // By default, show the latest quarter of data\n    // TODO Option to change default - or just use update()?\n    const latest = this.X[this.X.length - 1];\n\n    this.pie = d3\n      .pie()\n      .sort(null)\n      .value((d) => d.y)\n      .startAngle(this.config.START_ANGLE)\n      .endAngle(this.config.END_ANGLE);\n\n    this.arc = d3\n      .arc()\n      .innerRadius(this.innerRadius)\n      .outerRadius(this.outerRadius);\n\n    // Radii when enlarged\n    this.arcEnlarge = d3\n      .arc()\n      .innerRadius(this.innerRadiusHover)\n      .outerRadius(this.outerRadiusHover);\n\n    const [midX, midY] = this.layout.midpoint;\n\n    this.slices = this.svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(${midX},${midY})`);\n\n    // Center value display\n    this.gDisplay = this.svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(${midX},${midY})`)\n      .attr(\"class\", \"display\")\n      .append(\"text\");\n\n    // Optional label\n    // this.slices\n    //   .append(\"text\")\n    //   .attr(\"class\", \"label\")\n    //   .attr(\"transform\", (d) => `translate(${this.arc.centroid(d)})`)\n    //   .text(d => this.getLabel(d));\n\n    if (!this.config.INITIAL_CLOSED) {\n      this.update(latest);\n    }\n  }\n\n  update(x) {\n    // Update the pie chart with the data at the given x value\n    const items = this.byX.get(x);\n\n    // TODO All Z items should be represented in the new data - it makes updates easier\n    const arcs = this.pie(items);\n    const path = this.slices.selectAll(\"path\").data(arcs, (d) => d.data.z);\n\n    // Need to use a closure because the attrTween uses this\n    const arc = this.arc;\n\n    // Update existing arcs\n    path\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attrTween(\"d\", function (d) {\n        const interpolate = d3.interpolate(this._current, d);\n        this._current = interpolate(0);\n        return (t) => arc(interpolate(t));\n      });\n\n    // Enter new arcs\n    path\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", \"slice\")\n      .attr(\"opacity\", 1.0)\n      .append(\"path\")\n      .attr(\"fill\", (d) => this.colors(d.data.z))\n      .each(function (d) {\n        this._current = d;\n      })\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attrTween(\"d\", (d) => {\n        if (this.config.SKIP_ENTER_ANIMATION) {\n          return () => arc(d);\n        }\n        const interpolate = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);\n        return (t) => arc(interpolate(t));\n      });\n  }\n\n  getLabel(d) {\n    // Custom method to return a label from the joined pie data\n    return \"\";\n  }\n\n  set display(value) {\n    this.gDisplay.text(value);\n  }\n\n  enlarge(z) {\n    this.slices\n      .selectAll(\"path\")\n      .filter((d) => d.data.z === z)\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", this.arcEnlarge);\n  }\n\n  reset() {\n    this.slices\n      .selectAll(\"path\")\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", this.arc);\n  }\n\n  noHighlight() {\n    this.slices\n      .selectAll(\"g\")\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"opacity\", 1.0);\n  }\n\n  highlight(z) {\n    this.slices\n      .selectAll(\"g\")\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"opacity\", (d) =>\n        d.data.z === z ? 1.0 : this.config.BACKGROUND_OPACITY,\n      );\n  }\n\n  onEvent(enter, leave) {\n    const pointerenter = (evt, d) => {\n      if (enter) {\n        enter.call(this, d, evt);\n      }\n    };\n\n    const pointerleave = (evt, d) => {\n      if (leave) {\n        leave.call(this, d, evt);\n      }\n    };\n\n    this.slices\n      .selectAll(\"path\")\n      .on(\"pointerenter\", pointerenter)\n      .on(\"pointerleave\", pointerleave);\n  }\n}\n\nexport function Donut(data, parser) {\n  return new PieChart(data, parser);\n}\n\nexport function Pie(data, parser) {\n  return new PieChart(data, parser).radii(0, 0.8).hoverRadii(0, 0.9);\n}\n\nexport function Gauge(data, parser) {\n  return new PieChart(data, parser)\n    .angles(-Math.PI * 0.65, Math.PI * 0.65)\n    .radii(0.5, 0.8)\n    .hoverRadii(0.55, 0.9);\n}\n", "/*\nLine chart\n*/\nimport * as d3 from \"d3\";\n\nimport { quantizeScheme } from \"./colors\";\nimport { layoutSVG } from \"./layout\";\nimport { className } from \"./text\";\nimport { maxLabelSize } from \"./ticks\";\nimport { throttle } from \"./throttle\";\n\nexport function parse3dArray(d) {\n  return {\n    x: d[0],\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport function parseTimeSeries3dArray(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport class LineChartWithZoom {\n  xFormat = null;\n  yFormat = null;\n\n  // Line charts expect data is the format [{x, y, z}...]\n  // Specify a parser or override parse() if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    // Default config\n    this.config = {\n      SCREEN_HEIGHT_PERCENT: 0.5,\n      DURATION_MS: 500,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      HIGHLIGHT_STROKE_WIDTH: 2.0, // Width when highlighted\n      STROKE_WIDTH: 1.5, // Width when not highlighted\n      DOT_RADIUS: 3.0, // Radius of the dot\n      ZOOM_EXTENT: [0.5, 32],\n      COLORS: d3.schemeCategory10, // TODO There's no way to change the default yet\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    // Items can be dynamically hidden from the chart\n    this.hidden = new Set();\n\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new Set(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Config chained methods */\n  screenHeightPercent(value) {\n    this.config.SCREEN_HEIGHT_PERCENT = value;\n    return this;\n  }\n\n  animationDuration(value) {\n    this.config.DURATION_MS = value;\n    return this;\n  }\n\n  noAnimation() {\n    return this.animationDuration(0);\n  }\n\n  useDiscreteScheme(scheme) {\n    this.colors = d3.scaleOrdinal().domain(this.Z).range(scheme);\n    return this;\n  }\n\n  useContinuousScheme(scheme, min = 0.0, max = 1.0) {\n    return this.useDiscreteScheme(\n      quantizeScheme(this.Z.length, scheme, min, max),\n    );\n  }\n\n  zoomExtent(min, max) {\n    this.config.ZOOM_EXTENT = [min, max];\n    return this;\n  }\n\n  disableZoom() {\n    return this.zoomExtent(1, 1);\n  }\n  /* End config chained methods */\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.Z, (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get visibleData() {\n    // TODO memoization\n    return d3.filter(this.data, (d) => !this.hidden.has(d.z));\n  }\n\n  get xDomain() {\n    return d3.extent(d3.map(this.visibleData, (d) => d.x));\n  }\n\n  get yDomain() {\n    return d3.extent(d3.map(this.visibleData, (d) => d.y));\n  }\n\n  get xScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0]);\n  }\n\n  get zoomIsDisabled() {\n    return this.config.ZOOM_EXTENT[0] === 1 && this.config.ZOOM_EXTENT[1] === 1;\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(3).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"));\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    this.layout.pad.left = d3.max([\n      this.layout.pad.left,\n      yLabelWidth + this.config.MARGIN_TICK + 5,\n    ]);\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(selector, this.config);\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    const x = this.xScale;\n    const y = this.yScale;\n\n    // Create a clip path for the inner data element to hide any overflow content\n    this.svg\n      .append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", \"inner-clip-path\")\n      .append(\"rect\")\n      .attr(\"width\", this.layout.innerWidth)\n      .attr(\"height\", this.layout.innerHeight);\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    const gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      )\n      .attr(\"clip-path\", \"url(#inner-clip-path)\");\n\n    const grouping = d3.group(this.data, (d) => d.z);\n\n    this.paths = gInner\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH)\n      .selectAll(\"path\")\n      .data(grouping)\n      .join(\"path\");\n\n    const zoomed = ({ transform }) => {\n      this.x = transform.rescaleX(x).interpolate(d3.interpolateRound);\n      this.y = transform.rescaleY(y).interpolate(d3.interpolateRound);\n      this.update(this.x, this.y);\n    };\n\n    this.zoom = d3\n      .zoom()\n      .scaleExtent(this.config.ZOOM_EXTENT)\n      .on(\"zoom\", zoomed.bind(this));\n\n    // Dot - shows nearest point during pointer events\n    this.dot = gInner.append(\"g\").attr(\"class\", \"dot\").style(\"display\", \"none\");\n    this.circle = this.dot.append(\"circle\").attr(\"r\", this.config.DOT_RADIUS);\n\n    this.reset();\n  }\n\n  update(x, y) {\n    // Hide the chart if there's no visible data\n    if (!this.visibleData.length) {\n      this.gx.attr(\"opacity\", 0.0);\n      this.gy.attr(\"opacity\", 0.0);\n      this.paths.attr(\"opacity\", 0.0);\n      return;\n    }\n\n    // Re-draw the chart with the new x and y scales\n    this.hideDot();\n    this.gx.call(this.xAxis.bind(this), x).attr(\"opacity\", 1.0);\n    this.gy.call(this.yAxis.bind(this), y).attr(\"opacity\", 1.0);\n    this.gGrid.call(this.grid.bind(this), x, y);\n\n    // Plot the line\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => x(d.x))\n      .y((d) => y(d.y));\n\n    this.paths\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"stroke\", ([z]) => this.colors(z))\n      .attr(\"class\", ([z]) => className(z))\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n  }\n\n  reset() {\n    const z = this.svg\n      .call(this.zoom)\n      .call(this.zoom.transform, d3.zoomIdentity);\n\n    if (this.zoomIsDisabled) {\n      // Disable zoom completely if requested\n      z.on(\"mousedown.zoom\", null)\n        .on(\"touchstart.zoom\", null)\n        .on(\"touchmove.zoom\", null)\n        .on(\"touchend.zoom\", null);\n    }\n  }\n\n  placeDot(index) {\n    // Place a dot at the given index\n    const d = this.data[index];\n    this.dot\n      .style(\"display\", null)\n      .attr(\"transform\", `translate(${this.x(d.x)},${this.y(d.y)})`);\n    this.circle.attr(\"fill\", this.colors(d.z));\n  }\n\n  hideDot() {\n    this.dot.style(\"display\", \"none\");\n  }\n\n  noHighlight() {\n    // Reset all lines to default\n    this.paths\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0))\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH);\n  }\n\n  highlight(z) {\n    // Hide paths that aren't the currently selected path\n    this.paths\n      .attr(\"opacity\", ([elem]) => {\n        if (this.hidden.has(elem)) return 0;\n        return elem === z ? 1.0 : this.config.BACKGROUND_OPACITY;\n      })\n      .attr(\"stroke-width\", ([elem]) =>\n        elem === z\n          ? this.config.HIGHLIGHT_STROKE_WIDTH\n          : this.config.STROKE_WIDTH,\n      );\n  }\n\n  onEvent(move, leave) {\n    let prevIndex = null;\n\n    // Determine the closest point to the cursor\n    const pointermove = (evt) => {\n      const [xm, ym] = d3.pointer(evt);\n      const points = d3.map(this.data, (d) => {\n        if (this.hidden.has(d.z)) return null;\n        return Math.hypot(this.x(d.x) - xm, this.y(d.y) - ym);\n      });\n\n      const index = d3.leastIndex(points);\n      if (index === -1 || points[index] === null) return;\n\n      // Exit early if no point was found\n      if (typeof index === \"undefined\") return;\n\n      // Only trigger the callback when the index changes\n      if (prevIndex && prevIndex == index) return;\n\n      this.placeDot(index);\n\n      const d = this.data[index];\n\n      let data = {\n        x: d.x,\n        y: d.y,\n        z: d.z,\n        dx: this.x(d.x),\n        dy: this.y(d.y),\n      };\n\n      if (move) {\n        move.call(this, data);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      this.hideDot();\n      if (leave) {\n        leave.call(this);\n      }\n    };\n\n    this.svg\n      .on(\"pointermove\", throttle(pointermove, 20.83)) // 48 fps\n      .on(\"pointerleave\", pointerleave)\n      .on(\"touchstart\", (evt) => {\n        pointermove(evt);\n        evt.preventDefault();\n      });\n  }\n\n  hide(...z) {\n    // Add the given z elements to the hidden set\n    this.hidden = this.hidden.union(new Set(z));\n    this.toggle();\n  }\n\n  show(...z) {\n    // Remove the given z elements from the hidden set\n    this.hidden = this.hidden.difference(new Set(z));\n    this.toggle();\n  }\n\n  hideAll() {\n    this.hidden = new Set(this.Z);\n    this.toggle();\n  }\n\n  showAll() {\n    this.hidden = new Set();\n    this.toggle();\n  }\n\n  toggle() {\n    // Recalculate the scales based on the non-hidden items\n    this.x = this.xScale;\n    this.y = this.yScale;\n    this.update(this.x, this.y);\n  }\n\n  // TODO method to append a data point\n  append() {}\n}\n\nexport function LineWithZoom(data, parser) {\n  return new LineChartWithZoom(data, parser);\n}\n\nexport class TimeSeriesChartWithZoom extends LineChartWithZoom {\n  get xScale() {\n    return d3\n      .scaleUtc()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n}\n\nexport function TimeSeriesWithZoom(data, parser) {\n  return new TimeSeriesChartWithZoom(data, parser);\n}\n"],
  "mappings": "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",
  "names": ["require_d3", "__commonJSMin", "exports", "module", "rates_exports", "__export", "Rates", "percentChange", "quarter", "d3", "d3", "d3", "quantizeScheme", "n", "scheme", "min", "max", "t", "Chart", "data", "parser", "d", "value", "CategoricalChart", "scheme", "min", "max", "quantizeScheme", "z", "d3", "Pad", "top", "right", "bottom", "left", "DefaultPad", "Pad", "Layout", "width", "height", "pad", "getLayout", "elem", "minWidth", "maxWidth", "minHeight", "maxHeight", "screenHeightPercent", "chart", "appendSVG", "selector", "width", "height", "layoutSVG", "config", "elem", "svg", "Layout", "layout", "getLayout", "d3", "className", "value", "d3", "maxLabelSize", "svg", "layout", "scale", "format", "cls", "hidden", "axis", "labels", "width", "height", "bbox", "throttle", "fn", "timeout", "free", "d3", "d3", "month", "monthDay", "monthYear", "monthDayYear", "fullMonthDayYear", "quarter", "d", "d3", "d3", "percent", "percentChange", "magnitude", "units", "d3", "getLength", "elem", "LineChart", "CategoricalChart", "data", "parser", "d", "__publicField", "visible", "z", "g", "x", "y", "xLabelWidth", "xLabelHeight", "maxLabelSize", "yLabelWidth", "yLabelHeight", "selector", "layoutSVG", "yTransform", "gInner", "grouping", "isEmpty", "line", "I", "className", "lengths", "i", "previousUpdate", "index", "move", "leave", "prevIndex", "pointermove", "evt", "xm", "ym", "points", "pointerleave", "throttle", "TimeSeriesChart", "LineChart", "data", "a", "b", "parser", "d3", "d3", "d3", "d3", "parseRateArray", "d", "RatesChart", "TimeSeriesChart", "data", "__publicField", "parseRateArray", "d", "selector", "tooltipID", "tooltip", "bbox", "rect", "names", "acc", "o", "onMove", "name", "q", "percent", "offsetY", "offsetX", "onLeave", "legend", "template", "item", "clone", "div", "evt", "z", "elem", "Rates"]
}
