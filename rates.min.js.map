{
  "version": 3,
  "sources": ["external-global-plugin:d3", "rates.js", "../node_modules/@aodin/charts/src/animation.js", "../node_modules/@aodin/charts/src/area.js", "../node_modules/@aodin/charts/src/chart.js", "../node_modules/@aodin/charts/src/colors.js", "../node_modules/@aodin/charts/src/layout.js", "../node_modules/@aodin/charts/src/parsers.js", "../node_modules/@aodin/charts/src/text.js", "../node_modules/@aodin/charts/src/throttle.js", "../node_modules/@aodin/charts/src/ticks.js", "../node_modules/@aodin/charts/src/tooltip.js", "../node_modules/@aodin/charts/src/bar.js", "../node_modules/@aodin/charts/src/timeseries.js", "../node_modules/@aodin/charts/src/candlestick.js", "../node_modules/@aodin/charts/src/formats.js", "../node_modules/@aodin/charts/src/line.js", "../node_modules/@aodin/charts/src/magnitude.js", "../node_modules/@aodin/charts/src/options.js", "../node_modules/@aodin/charts/src/pie.js", "../node_modules/@aodin/charts/src/zoom.js"],
  "sourcesContent": ["module.exports = d3", "/*\nExample exchange rate chart that extends a line chart\n*/\nimport * as d3 from \"d3\";\nimport {\n  TimeSeriesChart,\n  percentChange,\n  quarter,\n  placeTooltip,\n} from \"@aodin/charts\";\n\nfunction parseRateArray(d) {\n  // x, z, y\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[2],\n    z: d[1],\n  };\n}\n\nclass RatesChart extends TimeSeriesChart {\n  yFormat = d3.format(\"+,~%\");\n\n  constructor(data) {\n    super(data);\n    this.screenHeightPercent(0.75);\n    this.yAxisRight();\n    this.useContinuousScheme(d3.interpolateRainbow, 0.1, 0.9);\n  }\n\n  parseData(data) {\n    return d3.map(data.values, parseRateArray);\n  }\n\n  parseItems(data) {\n    return data.items;\n  }\n\n  parseZ(data) {\n    return d3.map(this.items, (d) => d.abbrev);\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.items, (d) => {\n      return Object.assign({ color: this.colors(d.abbrev) }, d);\n    });\n  }\n\n  render(selector) {\n    super.render(selector);\n\n    const tooltip = d3\n      .select(\"body\")\n      .append(\"div\")\n      .attr(\"class\", \"chart-tooltip\")\n      .style(\"pointer-events\", \"none\")\n      .style(\"position\", \"absolute\")\n      .style(\"visibility\", \"hidden\");\n\n    const names = this.legend.reduce((acc, o) => {\n      acc[o.abbrev] = o.name;\n      return acc;\n    }, {});\n\n    const onMove = (d, evt) => {\n      this.highlight(d.z);\n\n      // Set text of tooltip, then set coordinates\n      const name = names[d.z];\n      const q = quarter(d.x);\n      if (d.y) {\n        const percent = percentChange(d.y);\n        tooltip.html(\n          `<strong>${name}</strong></br><em>${q}</em></br>${percent}`,\n        );\n      } else {\n        tooltip.html(`<strong>${name}</strong></br><em>${q}</em>`);\n      }\n\n      const pad = evt.touchType ? 20 : 5;\n      const [tx, ty, align] = placeTooltip(\n        this.svg.node(),\n        tooltip.node(),\n        d.dx,\n        d.dy,\n        pad,\n      );\n\n      tooltip\n        .style(\"visibility\", null)\n        .style(\"text-align\", align)\n        .style(\"left\", `${tx}px`)\n        .style(\"top\", `${ty}px`);\n    };\n\n    const onLeave = () => {\n      this.noHighlight();\n      tooltip.style(\"visibility\", \"hidden\");\n    };\n\n    this.onEvent(onMove, onLeave);\n\n    // Draw the legend - pass as selectors?\n    const legend = document.querySelector(\"#legend\");\n    const template = document.querySelector(\"#legendTemplate\");\n\n    this.legend.forEach((item) => {\n      const clone = template.content.cloneNode(true);\n      const div = clone.querySelector(\"div\");\n      div.dataset.abbrev = item.abbrev;\n      div.dataset.hidden = \"\"; // Initial show/hide state can be set here\n\n      clone.querySelector(\"rect\").setAttribute(\"fill\", item.color);\n      clone.querySelector(\"span\").textContent = `${item.name}`;\n      legend.appendChild(clone);\n\n      // Create hover events that highlight chart on legend hover, but only if it's active\n      // NOTE This creates strange effects on mobile\n      // div.addEventListener(\"mouseover\", (elem) => {\n      //   if (div.dataset.hidden === \"\") {\n      //     this.highlight(item.abbrev);\n      //   } else {\n      //     this.noHighlight();\n      //   }\n      // });\n\n      // Show only that item when double click\n      div.addEventListener(\"dblclick\", (evt) => {\n        const z = [];\n        // TODO Another approach: if the currently double clicked item is the only one\n        // shown, then show everything\n        if (div.dataset.hidden === \"\") {\n          // Hide everything except the current item\n          Array.from(legend.children).forEach((elem) => {\n            if (elem.dataset.abbrev === item.abbrev) {\n              elem.dataset.hidden = \"\";\n            } else {\n              z.push(elem.dataset.abbrev);\n              elem.dataset.hidden = true;\n            }\n          });\n        } else {\n          // If the item is already hidden, just show everything again\n          Array.from(legend.children).forEach((elem) => {\n            elem.dataset.hidden = \"\";\n          });\n        }\n        z.length ? this.hide(...z) : this.showAll();\n        evt.preventDefault();\n      });\n\n      // Hide the item on single click, unless it is already hidden, then show\n      div.addEventListener(\"click\", (evt) => {\n        if (div.dataset.hidden === \"\") {\n          this.hide(item.abbrev);\n          div.dataset.hidden = \"true\";\n        } else {\n          this.show(item.abbrev);\n          div.dataset.hidden = \"\";\n        }\n      });\n    });\n  }\n}\n\nexport function Rates(data) {\n  return new RatesChart(data);\n}\n", "/*\nAnimation helper functions.\n*/\n\nimport * as d3 from \"d3\";\n\nexport function animatedDashArray(pattern, totalLength) {\n  pattern = pattern || [];\n  // Returns the stroke-dasharray string that can be used to animate a dashed line\n  // Pattern should be an array of integers, with an empty array being a solid line\n  if (!pattern.length) return `${totalLength} ${totalLength}`;\n\n  if (pattern.length % 2) {\n    pattern = pattern.concat(pattern);\n  }\n\n  const dash = pattern.join(\" \"); // The pattern that will be repeated as a string\n  const dashLength = d3.sum(pattern);\n  if (!dashLength) return `${totalLength} ${totalLength}`;\n  const count = Math.ceil(totalLength / dashLength);\n  const repeated = new Array(count).fill(dash).join(\" \");\n\n  // After the repeated portion, show an empty section the length of the line\n  // This empty section will give the appearance of opening as its offset is changed\n  return `${repeated} 0 ${Math.ceil(totalLength)}`;\n}\n\nexport function animatedDashOffset(pattern, totalLength) {\n  // Returns the stroke-dashoffset string that can be used to animate a dashed line\n  pattern = pattern || [];\n\n  if (pattern.length % 2) {\n    pattern = pattern.concat(pattern);\n  }\n\n  const dashLength = d3.sum(pattern);\n  if (dashLength) {\n    return (t) => Math.round(((1 - t) * totalLength) / dashLength) * dashLength;\n  }\n  return d3.interpolate(totalLength, 0);\n}\n\nexport function updatePattern(pattern, ratio) {\n  return d3.map(pattern, (d) => d * ratio);\n}\n", "/*\nArea chart\n*/\nimport * as d3 from \"d3\";\n\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { throttle } from \"./throttle\";\nimport { maxLabelSize } from \"./ticks\";\nimport { placeTooltip, placeTooltipTop } from \"./tooltip\";\n\nexport { parse3dArray, parseTimeSeries3dArray, placeTooltip, placeTooltipTop };\n\n// Clip paths require a unique ID\nlet uniqueID = 0;\n\nexport class AreaChart extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Area charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      LAYOUT: {},\n      DURATION_MS: 500,\n      FPS: 48,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      Y_AXIS_RIGHT: false,\n      COLORS: d3.schemeCategory10,\n      OVERFLOW: false, // Allow overflow of the SVG element\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        return item && item.y ? item.y : 0;\n      })(indexed);\n\n    // Largest items are returned first, since the stack areas are all drawn from zero\n    return stack.reverse();\n  }\n\n  get stack() {\n    // Only visible data - hidden items are all zero\n    return this.getStack(this.visibleData);\n  }\n\n  get fullStack() {\n    // All data\n    return this.getStack(this.data);\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    // TODO SHould legend order be reversed?\n    return d3.map(this.Z.slice().reverse(), (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get visibleData() {\n    // TODO memoization\n    // return d3.filter(this.data, (d) => !this.hidden.has(d.z));\n    // Set hidden values to zero\n    return d3.map(this.data, (d) =>\n      this.hidden.has(d.z) ? { x: d.x, y: 0, z: d.z } : d,\n    );\n  }\n\n  get xDomain() {\n    // By default, don't re-calculate the x-axis\n    return d3.extent(d3.map(this.data, (d) => d.x));\n  }\n\n  get yDomain() {\n    // Always show the full y Axis\n    return [0, d3.max(this.fullStack[0], (d) => d[1])];\n  }\n\n  get xScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0])\n      .nice();\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(3).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    if (this.config.Y_AXIS_RIGHT) {\n      g.call(d3.axisRight(y).tickSize(0).tickFormat(this.yFormat));\n    } else {\n      g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n    }\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"))\n      .selectAll(\".tick\")\n      .each(function (d) {\n        d3.select(this).classed(\"zero\", d === 0);\n      });\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced, but we still need room for the x-scale tick labels\n      this.layout.pad.left = 15;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(\n      selector,\n      this.config.LAYOUT,\n      this.config.OVERFLOW,\n    );\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    this.x = this.xScale;\n    this.y = this.yScale;\n\n    // Start with the SVG visible - this can be set to 0 for \"fade in\"\n    this.svg.attr(\"opacity\", 1.0);\n\n    // First items drawn are lower layers\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    this.gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    let yTransform = `translate(${this.layout.pad.left - this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    if (this.config.Y_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.pad.left + this.layout.innerWidth + this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    }\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\"transform\", yTransform);\n\n    // Set initial state\n    this.gx.call(this.xAxis.bind(this), this.x).attr(\"opacity\", 1.0);\n    this.gy.call(this.yAxis.bind(this), this.y);\n    this.gGrid.call(this.grid.bind(this), this.x, this.y);\n\n    // Draw the zero state areas\n    const area = d3\n      .area()\n      .x((d) => this.x(d.data[0]))\n      .y0((d) => this.y(0))\n      .y1((d) => this.y(0));\n\n    this.areas = this.gInner\n      .append(\"g\")\n      .selectAll()\n      .data(this.stack)\n      .join(\"path\")\n      .attr(\"fill\", (d) => this.colors(d.key))\n      .attr(\"class\", (d) => className(d.key))\n      .attr(\"d\", area);\n\n    this.update(this.x, this.y);\n  }\n\n  update(x, y) {\n    // Draw visible areas - always from 0\n    const area = d3\n      .area()\n      .x((d) => x(d.data[0]))\n      .y0((d) => y(0))\n      .y1((d) => y(d[1]));\n\n    this.areas\n      .data(this.stack)\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", area);\n  }\n\n  noHighlight() {\n    // Reset all areas to default\n    // this.areas.attr(\"fill\", (d) => this.colors(d.key));\n    // this.areas.attr(\"opacity\", 1.0);\n  }\n\n  highlight(z) {\n    // TODO Make the given z more prominent - two possibilities\n    // this.areas.attr(\"fill\", (d) => d.key === z ? this.colors(d.key) : \"#ddd\");\n    // this.areas.attr(\"opacity\", (d) => d.key === z ? 1.0 : this.config.BACKGROUND_OPACITY);\n  }\n\n  onEvent(move, leave) {\n    const xs = [...d3.group(this.data, (d) => d.x).keys()];\n    const coords = d3.map(xs, this.x);\n\n    // Organize the data by key and x\n    const indexed = d3.index(\n      this.data,\n      (d) => d.z,\n      (d) => d.x,\n    );\n\n    const pointermove = (evt, d) => {\n      let key = d.key;\n      if (evt.touches) {\n        evt.preventDefault(); // Prevent scroll on touch devices\n        evt = evt.touches[0];\n        const target = document.elementFromPoint(evt.clientX, evt.clientY);\n        if (!target) return;\n        const targetData = d3.select(target).datum();\n        // TODO Trigger a pointerleave?\n        if (!targetData) return;\n        key = targetData.key;\n        if (!key) return;\n      }\n      let [xm, ym] = d3.pointer(evt, this.gInner.node());\n      const index = d3.bisectCenter(coords, xm);\n      const point = indexed.get(key).get(xs[index]);\n\n      // Data that will be provided to the callback: include the page coordinates\n      // of the pointer\n      const [px, py] = d3.pointer(evt, null);\n\n      const data = {\n        x: point.x,\n        y: point.y,\n        z: point.z,\n        // NOTE: Since there's no relevant point for events, use the pointer\n        dx: px,\n        dy: py,\n        // Pointer page coordinates\n        px: px,\n        py: py,\n      };\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt, d) => {\n      if (leave) {\n        leave.call(this, d.key, evt);\n      }\n    };\n\n    // Separate mouse and touch events\n    this.areas\n      .on(\"mousemove\", throttle(pointermove, 1000.0 / this.config.FPS))\n      .on(\"mouseleave\", pointerleave)\n      .on(\"touchstart\", pointermove, { passive: false })\n      .on(\"touchmove\", throttle(pointermove, 1000.0 / this.config.FPS), {\n        passive: false,\n      })\n      .on(\"touchend\", pointerleave, { passive: false });\n  }\n\n  toggle() {\n    this.update(this.x, this.y);\n  }\n}\n\nexport function Area(data, parser) {\n  return new AreaChart(data, parser);\n}\n\nexport class TimeSeriesAreaChart extends AreaChart {\n  get xScale() {\n    // Never re-calculate the x-axis\n    return d3\n      .scaleUtc()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  sortData(data) {\n    data.sort((a, b) => a.x - b.x);\n    return data;\n  }\n\n  parseData(data, parser) {\n    // Sort timeseries data in ascending order\n    return this.sortData(super.parseData(data, parser));\n  }\n}\n\nexport function TimeSeriesArea(data, parser) {\n  return new TimeSeriesAreaChart(data, parser);\n}\n\nexport class TimeSeriesSharesChart extends TimeSeriesAreaChart {\n  yFormat = d3.format(\".0%\");\n\n  constructor(data, parser) {\n    super(data, parser);\n\n    // Determine the total per x\n    this.totals = d3.rollup(\n      this.data,\n      (v) => d3.sum(v, (d) => d.y),\n      (d) => d.x,\n    );\n  }\n\n  // Use the stack to calculate shares\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        const total = this.totals.get(item.x);\n        return item && item.y && total ? item.y / total : 0;\n      })(indexed);\n\n    // Largest items are returned first, since the stack areas are all drawn from zero\n    return stack.reverse();\n  }\n\n  get yDomain() {\n    // Share charts will always be 0 to 1.0\n    return [0.0, 1.0];\n  }\n}\n\nexport function TimeSeriesShares(data, parser) {\n  return new TimeSeriesSharesChart(data, parser);\n}\n", "import * as d3 from \"d3\";\n\nimport { quantizeScheme } from \"./colors\";\n\nexport class Chart {\n  // Base class for charts\n  // Currently only has some common chained config methods for layout and animation\n\n  constructor(data, parser = (d) => d) {}\n\n  /* Config chained methods */\n  screenHeightPercent(value) {\n    this.config.LAYOUT.screenHeightPercent = value;\n    return this;\n  }\n\n  minHeight(value) {\n    this.config.LAYOUT.minHeight = value;\n    return this;\n  }\n\n  maxHeight(value) {\n    this.config.LAYOUT.maxHeight = value;\n    return this;\n  }\n\n  height(value) {\n    return this.minHeight(value).maxHeight(value);\n  }\n\n  minWidth(value) {\n    this.config.LAYOUT.minWidth = value;\n    return this;\n  }\n\n  maxWidth(value) {\n    this.config.LAYOUT.maxWidth = value;\n    return this;\n  }\n\n  width(value) {\n    return this.minWidth(value).maxWidth(value);\n  }\n\n  animationDuration(value) {\n    this.config.DURATION_MS = value;\n    return this;\n  }\n\n  noAnimation() {\n    // Set both transition and overlay to 0\n    this.config.DELAY_MS = 0;\n    return this.animationDuration(0);\n  }\n\n  overflowVisible() {\n    this.config.OVERFLOW = true;\n    return this;\n  }\n\n  node() {\n    // Return the chart svg node. Return null if the chart hasn't been rendered.\n    return this.svg ? this.svg.node() : null;\n  }\n}\n\nexport class CategoricalChart extends Chart {\n  // Adds additional chained config methods for schemes and hidden state\n\n  constructor(data, parser = (d) => d) {\n    // Items can be dynamically hidden from the chart\n    super(data, parser);\n    this.hidden = new d3.InternSet();\n  }\n\n  /* Chained config methods */\n  backgroundOpacity(value) {\n    this.config.BACKGROUND_OPACITY = value;\n    return this;\n  }\n\n  yAxisRight() {\n    // The y axis ticks and labels will be shown on the right of the chart\n    this.config.Y_AXIS_RIGHT = true;\n    return this;\n  }\n\n  useDiscreteScheme(scheme) {\n    this.colors = d3.scaleOrdinal().domain(this.Z).range(scheme);\n    return this;\n  }\n\n  useContinuousScheme(scheme, min = 0.0, max = 1.0) {\n    return this.useDiscreteScheme(\n      quantizeScheme(this.Z.length, scheme, min, max),\n    );\n  }\n\n  invertScheme() {\n    this.colors = this.colors.range(this.colors.range().reverse());\n    return this;\n  }\n\n  startHidden() {\n    // The first render will have all items hidden\n    this.hidden = new d3.InternSet(this.Z);\n    return this;\n  }\n  /* End chained config methods */\n\n  hide(...z) {\n    // Add the given z elements to the hidden set\n    this.hidden = this.hidden.union(new d3.InternSet(z));\n    this.toggle();\n  }\n\n  show(...z) {\n    // Remove the given z elements from the hidden set\n    this.hidden = this.hidden.difference(new d3.InternSet(z));\n    this.toggle();\n  }\n\n  setHidden(...z) {\n    this.hidden = new d3.InternSet(z);\n  }\n\n  hideAll() {\n    this.hidden = new d3.InternSet(this.Z);\n    this.toggle();\n  }\n\n  showAll() {\n    this.hidden.clear();\n    this.toggle();\n  }\n\n  showOnly(...z) {\n    // Show only the given z elements, all others will be hidden\n    this.hidden = new d3.InternSet(this.Z).difference(new d3.InternSet(z));\n    this.toggle();\n  }\n}\n", "import * as d3 from \"d3\";\n\nexport function quantizeScheme(n, scheme, min = 0.0, max = 1.0) {\n  if (n === 1) {\n    // If there is only one item, just use the middle of the scheme\n    return [scheme((max - min) / 2.0 + min)];\n  }\n  return d3.quantize((t) => scheme(t * (max - min) + min), n);\n}\n", "import * as d3 from \"d3\";\n\n/*\nMost of the layout operations are placing a rectangle within another rectangle.\nWhat is the most generic way to do this?\n*/\n\nexport class Pad {\n  constructor(top, right, bottom, left) {\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n}\n\nexport function EqualPad(value) {\n  return new Pad(value, value, value, value);\n}\n\nexport function DefaultPad() {\n  return new Pad(15, 15, 25, 25);\n}\n\nexport class Layout {\n  constructor(width, height, pad) {\n    this.width = width;\n    this.height = height;\n    this.pad = pad || DefaultPad();\n  }\n\n  get rangeX() {\n    return [this.pad.left, this.width - this.pad.right];\n  }\n\n  get rangeY() {\n    return [this.height - this.pad.bottom, this.pad.top];\n  }\n\n  get innerWidth() {\n    return this.width - this.pad.left - this.pad.right;\n  }\n\n  get innerHeight() {\n    return this.height - this.pad.top - this.pad.bottom;\n  }\n\n  get innerMinimum() {\n    return d3.min([this.innerWidth, this.innerHeight]);\n  }\n\n  get midpoint() {\n    return [this.width / 2, this.height / 2];\n  }\n}\n\nexport function getLayout(\n  elem,\n  {\n    minWidth = 400,\n    maxWidth = undefined,\n    minHeight = 300,\n    maxHeight = undefined,\n    screenHeightPercent = 0.5,\n  } = {},\n) {\n  const chart = document.querySelector(elem);\n  let width = d3.max([chart.offsetWidth, minWidth]);\n  if (maxWidth) {\n    width = d3.min([width, maxWidth]);\n  }\n\n  let height = window.innerHeight * screenHeightPercent;\n  height = d3.max([height, minHeight]);\n  if (maxHeight) {\n    height = d3.min([height, maxHeight]);\n  }\n  return new Layout(width, height, DefaultPad());\n}\n\nexport function maxTickWidth(defaults, height, domain, format, options) {\n  // Create a fake axis to test label tick size\n  const hidden = d3\n    .select(\"body\")\n    .append(\"svg\")\n    .attr(\"width\", 100)\n    .attr(\"height\", height)\n    .style(\"visibility\", \"hidden\"); // \"display: none\" does not work\n\n  let scale = d3\n    .scaleLinear()\n    .domain(domain)\n    .range([height - defaults.bottom, defaults.top]);\n\n  let axis = d3\n    .axisLeft(scale)\n    .tickFormat(format) // Can be null\n    .tickSize(0)\n    .ticks(8); // TODO Number of ticks as an option\n\n  const g = hidden.append(\"g\").style(\"font-size\", options.FONT_SIZE).call(axis);\n\n  // Measure the tick labels\n  const labels = g.selectAll(\".tick text\");\n\n  let width = 0;\n  labels.each(function () {\n    const bbox = this.getBoundingClientRect(); // TODO Or getBBox?\n    if (bbox.width > width) {\n      width = bbox.width;\n    }\n  });\n\n  // Remove the axis\n  hidden.remove();\n\n  // Pad\n  return width + options.X_TICK_GUTTER + 5;\n}\n\nexport function appendSVG(selector, width, height, overflow = false) {\n  // Append an SVG element to the selected element\n  return (\n    d3\n      .select(selector)\n      .append(\"svg\")\n      .attr(\"viewBox\", `0 0 ${width} ${height}`)\n      .attr(\"style\", \"max-width: 100%; height: intrinsic;\")\n      .style(\"-webkit-tap-highlight-color\", \"transparent\")\n      // For some charts, it might make sense to have the style overflow: visible\n      .style(\"overflow\", overflow ? \"visible\" : \"hidden\")\n  );\n}\n\nexport function layoutSVG(selector, options, overflow = false) {\n  // Return the SVG elements and its layout\n  // Available options:\n  // * screenHeightPercent\n  // * minWidth\n  // * maxWidth\n  // * minHeight\n  // * maxHeight\n  const elem = d3.select(selector);\n  if (!elem.node()) {\n    throw new Error(`Unable to find a DOM element for selector '${selector}'`);\n  }\n\n  if (elem.node().tagName === \"svg\") {\n    const svg = elem;\n    const width = +svg.attr(\"width\");\n    const height = +svg.attr(\"height\");\n    // TODO Fallback to viewbox\n    if (width && height) {\n      return [svg, new Layout(width, height)];\n    } else {\n      // TODO SVGs must have a width or height or the defaults will be returned\n      const layout = getLayout(selector, options);\n      return [svg, layout];\n    }\n  }\n\n  const layout = getLayout(selector, options);\n  const svg = appendSVG(selector, layout.width, layout.height, overflow);\n  return [svg, layout];\n}\n", "import * as d3 from \"d3\";\n\nexport function parseArrayOHLCV(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    o: d[1],\n    h: d[2],\n    l: d[3],\n    c: d[4],\n    v: d[5],\n  };\n}\n\nexport function parseVerboseOHLCV(d) {\n  return {\n    x: d3.isoParse(d.date),\n    o: d.open,\n    h: d.high,\n    l: d.low,\n    c: d.close,\n    v: d.volume,\n  };\n}\n\nexport function parse3dArray(d) {\n  return {\n    x: d[0],\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport function parseTimeSeries3dArray(d) {\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[1],\n    z: d[2],\n  };\n}\n\nexport function parseTimeSeries2dArray(d) {\n  // No z axis\n  return {\n    x: d3.isoParse(d[0]),\n    y: d[1],\n    z: \"\",\n  };\n}\n\nexport function parseArrayYZ(d) {\n  // For data without an x-axis\n  return {\n    x: null,\n    y: d[0],\n    z: d[1],\n  };\n}\n", "const invalidChars = /[^a-zA-Z0-9_-]/g;\nconst invalidStart = /^[^a-zA-Z_]/;\n\nexport function className(value) {\n  // Sanitize the given string so it can be used as a class name\n  // Spaces will be replaced with underscores, other invalid characters will be removed\n  value = String(value).trim().replaceAll(\" \", \"_\").replace(invalidChars, \"\");\n\n  // Prepend an underscore if the name starts will an invalid character\n  if (invalidStart.test(value)) {\n    value = \"_\" + value;\n  }\n  return value;\n}\n", "export function throttle(fn, timeout) {\n  var free = true;\n  return function () {\n    if (free) {\n      fn.apply(this, arguments);\n      free = false;\n      setTimeout(() => {\n        free = true;\n      }, timeout);\n    }\n  };\n}\n", "import * as d3 from \"d3\";\n\nexport function maxLabelSize(svg, layout, scale, format = null, cls = \"\") {\n  // Create a fake axis to test label tick size\n  // Does not include the tick size or padding, is just the label width\n  // This access should be part of the current chart's selection and have the same\n  // class values in order to correctly match any CSS that changes label sizes\n  const hidden = svg\n    .append(\"g\")\n    .attr(\"width\", layout.innerWidth)\n    .attr(\"height\", layout.innerHeight)\n    .attr(\"class\", cls)\n    .style(\"visibility\", \"hidden\"); // \"display: none\" does not work\n\n  const axis = d3.axisLeft(scale).tickFormat(format); // Can be null\n  const g = hidden.call(axis);\n\n  // Measure the tick labels\n  const labels = g.selectAll(\".tick text\");\n\n  let width = 0;\n  let height = 0;\n  labels.each(function () {\n    const elem = this.getBoundingClientRect(); // TODO Or getBBox?\n    if (elem.width > width) {\n      width = elem.width;\n    }\n    if (elem.height > height) {\n      height = elem.height;\n    }\n  });\n\n  hidden.remove();\n  return [width, height];\n}\n\n/*\nIn order to filter categorical ticks, we need:\n1. the width of the largest tick label\n2. the total available width for the axes in the layout\n3. the interval that will fit that largest label without overlap\n4. then filter the available tick labels by the interval\nAn optional offset can be provided, which will skip the ticks with a lower index\n*/\nexport function filterTicks(ticks, layout, labelWidth, offset = 0) {\n  const count = parseInt(layout.innerWidth / (labelWidth + 1)) + 1;\n  const interval = d3.max([parseInt(Math.ceil(ticks.length / count)), 1]);\n  return d3.filter(\n    ticks,\n    (d, i) => i - offset >= 0 && (i - offset) % interval === 0,\n  );\n}\n\n// Another variant of filterTicks that automatically determines an offset\nexport function filterTicksAutoOffset(ticks, layout, labelWidth) {\n  const count = parseInt(layout.innerWidth / (labelWidth + 1)) + 1;\n  const interval = d3.max([parseInt(Math.ceil(ticks.length / count)), 1]);\n  const offset = interval > 1 ? Math.floor(interval / 2) : 0;\n  return d3.filter(\n    ticks,\n    (d, i) => i - offset >= 0 && (i - offset) % interval === 0,\n  );\n}\n\nexport function invertBand(scale, x) {\n  const domain = scale.domain();\n  const index = Math.floor((x - scale(domain[0])) / scale.step());\n  return Math.max(0, Math.min(index, domain.length - 1));\n}\n\nexport function zoomRange(domain, width, start, end) {\n  // Return the range extent needed to zoom to the start and end indices of the domain\n  let w = end - start + 1;\n  let ratio = 1;\n  if (w < domain.length) {\n    ratio = domain.length / w;\n  }\n  const zoomWidth = width * ratio;\n  const offsetX = (start / domain.length) * zoomWidth;\n  return [0 - offsetX, zoomWidth - offsetX];\n}\n", "export function placeTooltip(container, tooltip, dx, dy, padding = 5) {\n  // Returns x and y page coordinates and text-align that will optimally place the\n  // tooltip in the container. The container and tooltip must be DOM elements with\n  // offset properties. The dx and dy should be page x and y of the event.\n  const bbox = container.getBoundingClientRect();\n  const px = dx - bbox.left - window.scrollX;\n  const py = dy - bbox.top - window.scrollY;\n\n  let x = padding;\n  let y = -tooltip.offsetHeight - padding;\n  let align = \"left\";\n\n  // TODO Limit to half the container?\n  if (px > bbox.width - tooltip.offsetWidth - padding) {\n    // Right side of container\n    x = -tooltip.offsetWidth - padding;\n    align = \"right\";\n  }\n\n  if (py < tooltip.offsetHeight + padding) {\n    // Top of the container\n    y = padding;\n  }\n\n  return [dx + x, dy + y, align];\n}\n\nexport function placeTooltipTop(container, tooltip, dx, dy, padding = 5) {\n  // Similar to placeTooltip, but always places the tooltip above the dx, dy\n  const bbox = container.getBoundingClientRect();\n  const px = dx - bbox.left - window.scrollX;\n\n  let x = padding;\n  let y = -tooltip.offsetHeight - padding;\n  let align = \"left\";\n\n  // TODO Limit to half the container?\n  if (px > bbox.width - tooltip.offsetWidth - padding) {\n    // Right side of container\n    x = -tooltip.offsetWidth - padding;\n    align = \"right\";\n  }\n\n  return [dx + x, dy + y, align];\n}\n\nexport function pageXY(node) {\n  // Get the page x and y of the given node\n  const svg = node.ownerSVGElement || node;\n  if (svg.createSVGPoint) {\n    let point = svg.createSVGPoint();\n    point = point.matrixTransform(node.getScreenCTM());\n    return [point.x + +window.scrollX, point.y + +window.scrollY];\n  }\n  if (node.getBoundingClientRect) {\n    // Calculate the page coordinates by adding the scroll offsets\n    const rect = node.getBoundingClientRect();\n    return [rect.left + window.scrollX, rect.top + window.scrollY];\n  }\n  return [undefined, undefined];\n}\n", "/*\nBar chart\n*/\nimport * as d3 from \"d3\";\n\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { throttle } from \"./throttle\";\nimport { maxLabelSize, filterTicksAutoOffset } from \"./ticks\";\nimport { makeDateFormatter } from \"./timeseries\";\nimport { placeTooltip, placeTooltipTop } from \"./tooltip\";\n\nexport { parse3dArray, parseTimeSeries3dArray, placeTooltip, placeTooltipTop };\n\n// Clip paths require a unique ID\nlet uniqueID = 0;\n\nfunction consistentOrderDiverging(fullStack) {\n  // NOTE getStack() reverses the stack\n  let stack = fullStack.slice().reverse();\n  return function (series, order) {\n    if (!((n = series.length) > 0)) return;\n    for (\n      var i, j = 0, prev, d, dy, yp, yn, n, m = series[order[0]].length;\n      j < m;\n      ++j\n    ) {\n      for (yp = yn = 0, i = 0; i < n; ++i) {\n        if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {\n          (d[0] = yp), (d[1] = yp += dy);\n        } else if (dy < 0) {\n          (d[1] = yn), (d[0] = yn += dy);\n        } else {\n          // If the item is zero, place it on the correct stack for its full value\n          if ((prev = stack[i][j][0]) > 0) {\n            (d[0] = yp), (d[1] = yp += dy);\n          } else if (prev < 0) {\n            (d[1] = yn), (d[0] = yn += dy);\n          } else {\n            (d[0] = 0), (d[1] = dy);\n          }\n        }\n      }\n    }\n  };\n}\n\nexport class BarChart extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Bar charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n    // Default config\n    this.config = {\n      BAND_PAD: 0.2,\n      BAR_STROKE_WIDTH: 1.0,\n      DURATION_MS: 500,\n      FPS: 48,\n      DELAY_MS: 0,\n      DELAY_ONCE: false,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      Y_AXIS_RIGHT: false,\n      COLORS: d3.schemeCategory10,\n      OVERFLOW: false, // Allow overflow of the SVG element\n      LAYOUT: {},\n      STACK_ORDER: d3.stackOrderNone, // E.g. stackOrderAppearance\n      STACK_OFFSET: d3.stackOffsetDiverging, // E.g. stackOffsetDiverging, stackOffsetNone\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    this.opened = false; // Is set true after the initial animation\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Config chained methods */\n  bandPadding(value) {\n    this.config.BAND_PAD = value;\n    return this;\n  }\n\n  barOutline(value) {\n    this.config.BAR_STROKE_WIDTH = value;\n    return this;\n  }\n\n  noBarOutline() {\n    return this.barOutline(0.0);\n  }\n\n  staggerOpening(value = 0) {\n    // Stagger only the opening animation\n    this.config.DELAY_ONCE = true;\n    return this.staggerAnimation(value);\n  }\n\n  staggerAnimation(value = 0) {\n    // If not value is provided, stagger by a fraction of the total animation\n    if (!value) {\n      value = this.config.DURATION_MS / (this.xDomain.length + 1);\n    }\n    this.config.DELAY_MS = value;\n    return this;\n  }\n\n  noStaggerAnimation() {\n    this.config.DELAY_MS = 0;\n    return this;\n  }\n  /* End config chained methods */\n\n  duration(d, i) {\n    if (this.config.DELAY_ONCE && this.opened) {\n      return this.config.DURATION_MS;\n    }\n    return this.config.DURATION_MS / 2;\n  }\n\n  delay(d, i) {\n    return this.config.DELAY_ONCE && this.opened ? 0 : i * this.config.DELAY_MS;\n  }\n\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        return item && item.y ? item.y : 0;\n      })\n      .offset(this.config.STACK_OFFSET)\n      .order(this.config.STACK_ORDER)(indexed);\n\n    // Largest items are returned first, since the stack areas are all drawn from zero\n    return stack.reverse();\n  }\n\n  get stack() {\n    // Only visible data - hidden items are all zero\n    return this.getStack(this.visibleData);\n  }\n\n  get fullStack() {\n    // All data\n    return this._fullStack;\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.Z.slice().reverse(), (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get visibleData() {\n    // TODO memoization\n    // Set hidden values to zero\n    return d3.map(this.data, (d) =>\n      this.hidden.has(d.z) ? { x: d.x, y: 0, z: d.z } : d,\n    );\n  }\n\n  get xDomain() {\n    // By default, don't re-calculate the x-axis\n    // Return all unique x values\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.x)));\n  }\n\n  get yDomain() {\n    // Always show the full y Axis\n    return d3.extent(this.fullStack.flat().flat());\n  }\n\n  get xScale() {\n    return d3\n      .scaleBand()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth])\n      .padding(this.config.BAND_PAD)\n      .align(0.1);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0])\n      .nice();\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(4).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    if (this.config.Y_AXIS_RIGHT) {\n      g.call(d3.axisRight(y).tickSize(0).tickFormat(this.yFormat));\n    } else {\n      g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n    }\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"))\n      .selectAll(\".tick\")\n      .each(function (d) {\n        d3.select(this).classed(\"zero\", d === 0);\n      });\n  }\n\n  groupClass(d, i) {\n    return className(d.key);\n  }\n\n  barClass(d, i) {\n    return \"\";\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced, but we still need room for the x-scale tick labels\n      this.layout.pad.left = 10;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // Calculate the full stack and cache it\n    this._fullStack = this.getStack(this.data);\n    this.config.STACK_OFFSET = consistentOrderDiverging(this._fullStack);\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(\n      selector,\n      this.config.LAYOUT,\n      this.config.OVERFLOW,\n    );\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    this.x = this.xScale;\n    this.y = this.yScale;\n\n    // Start with the SVG visible - this can be set to 0 for \"fade in\"\n    this.svg.attr(\"opacity\", 1.0);\n\n    // First items drawn are lower layers\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    this.gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    let yTransform = `translate(${this.layout.pad.left - this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    if (this.config.Y_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.pad.left + this.layout.innerWidth + this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    }\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\"transform\", yTransform);\n\n    // Set initial state\n    this.gx.call(this.xAxis.bind(this), this.x).attr(\"opacity\", 1.0);\n    this.gy.call(this.yAxis.bind(this), this.y);\n    this.gGrid.call(this.grid.bind(this), this.x, this.y);\n\n    this.groups = this.gInner\n      .append(\"g\")\n      .selectAll()\n      .data(this.stack)\n      .join(\"g\")\n      .attr(\"fill\", (d) => this.colors(d.key))\n      .attr(\"class\", this.groupClass)\n      .attr(\"opacity\", 1.0);\n\n    this.bars = this.groups\n      .selectAll(\"rect\")\n      .data((D) => D)\n      .join(\"rect\")\n      .attr(\"class\", this.barClass)\n      .attr(\"stroke-width\", this.config.BAR_STROKE_WIDTH)\n      .attr(\"x\", (d) => this.x(d.data[0]))\n      .attr(\"y\", (d) => this.y(0))\n      .attr(\"height\", (d) => 0)\n      .attr(\"width\", this.x.bandwidth());\n\n    this.update(this.x, this.y);\n  }\n\n  update(x, y) {\n    this.groups.data(this.stack);\n    this.bars\n      .data((D) => D)\n      .transition()\n      .delay(this.delay.bind(this))\n      .duration(this.duration.bind(this))\n      .attr(\"stroke-width\", this.config.BAR_STROKE_WIDTH)\n      .attr(\"x\", (d, i) => this.x(d.data[0]))\n      .attr(\"y\", (d) => (d[1] > d[0] ? this.y(d[1]) : this.y(d[0])))\n      .attr(\"height\", (d) => {\n        if (d[1] > d[0]) {\n          return this.y(d[0]) - this.y(d[1]);\n        }\n        return this.y(d[1]) - this.y(d[0]);\n      });\n    this.opened = true;\n  }\n\n  noHighlight() {\n    this.groups.attr(\"opacity\", 1.0);\n  }\n\n  highlight(z) {\n    this.groups.attr(\"opacity\", (d) =>\n      d.key === z ? 1.0 : this.config.BACKGROUND_OPACITY,\n    );\n  }\n\n  onEvent(move, leave) {\n    const pointermove = (evt, d) => {\n      // Touch events keep the target where the touch event started\n      let target = evt.target;\n\n      if (evt.touches) {\n        evt.preventDefault(); // Prevent scroll on touch devices\n        evt = evt.touches[0];\n        // Get the element at the current touch event\n        target = document.elementFromPoint(evt.clientX, evt.clientY);\n        // If the target element doesn't have a parent or data, exit early\n        // This likely means it is a non-bar element\n        // TODO Trigger a pointerleave?\n        if (!target || !target.parentNode) return;\n        d = d3.select(target).datum();\n        if (!d || !d.data) return;\n      }\n\n      const barData = d3.select(target.parentNode).data();\n      if (!barData) return;\n\n      // TODO Is this really the best way to get the data?\n      const x = d.data[0];\n      const y = d[0] < 0 ? d[0] - d[1] : d[1] - d[0];\n      const z = barData[0].key;\n\n      // Data that will be provided to the callback: include both the coordinates\n      // of the bar and the pointer, both in relation to the page\n      // TODO Why doesn't pageXY work with the rectangle?\n      const rect = target.getBoundingClientRect();\n      const [px, py] = d3.pointer(evt, null);\n      const data = {\n        x: x,\n        y: y,\n        z: z,\n        // Bar page coordinates\n        dx: rect.x + window.scrollX,\n        dy: rect.y + window.scrollY,\n        // Pointer page coordinates\n        px: px,\n        py: py,\n      };\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt, d) => {\n      if (leave) {\n        leave.call(this, d.key, evt);\n      }\n    };\n\n    // Separate mouse and touch events\n    this.bars\n      .on(\"mousemove\", throttle(pointermove, 1000.0 / this.config.FPS))\n      .on(\"mouseleave\", pointerleave)\n      .on(\"touchstart\", pointermove, { passive: false })\n      .on(\"touchmove\", throttle(pointermove, 1000.0 / this.config.FPS), {\n        passive: false,\n      })\n      .on(\"touchend\", pointerleave, { passive: false });\n  }\n\n  toggle() {\n    this.update(this.x, this.y);\n  }\n}\n\nexport function Bar(data, parser) {\n  return new BarChart(data, parser);\n}\n\nexport class TimeSeriesBarChart extends BarChart {\n  constructor(data, parser) {\n    super(data, parser);\n  }\n\n  // TODO How to better integrate with xFormat?\n  makeDateFormatter() {\n    return makeDateFormatter();\n  }\n\n  // TODO Declaring an xFormat getter doesn't override the xFormat attribute?\n  get xFormat() {\n    return makeDateFormatter();\n  }\n\n  get xValues() {\n    return filterTicksAutoOffset(this.xDomain, this.layout, this.xLabelWidth);\n  }\n\n  xAxis(g, x) {\n    g.call(\n      d3\n        .axisBottom(x)\n        .tickSize(4)\n        .tickValues(this.xValues)\n        .tickFormat(this.makeDateFormatter()),\n    );\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.makeDateFormatter(),\n      \"x axis\",\n    );\n    this.xLabelWidth = xLabelWidth;\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced, but we still need room for the x-scale tick labels\n      this.layout.pad.left = 15;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  sortData(data) {\n    data.sort((a, b) => a.x - b.x);\n    return data;\n  }\n\n  parseData(data, parser) {\n    // Sort timeseries data in ascending order\n    return this.sortData(super.parseData(data, parser));\n  }\n}\n\nexport function TimeSeriesBar(data, parser) {\n  return new TimeSeriesBarChart(data, parser);\n}\n\nexport class TimeSeriesBarSharesChart extends TimeSeriesBarChart {\n  // NOTE Although d3.stackOffsetExpand works great for static charts, we need a\n  // different strategy to handle dynamic hiding and showing of data\n  // Use d3.stackOffsetExpand if you want the visible items to always total 100%\n  yFormat = d3.format(\".0%\");\n\n  constructor(data, parser) {\n    super(data, parser);\n\n    // Determine the total per x\n    this.totals = d3.rollup(\n      this.data,\n      (v) => d3.sum(v, (d) => d.y),\n      (d) => d.x,\n    );\n  }\n\n  // Use the stack to calculate shares\n  getStack(data) {\n    // Index the data by x, then by z for each x\n    const indexed = d3.index(\n      data,\n      (d) => d.x,\n      (d) => d.z,\n    );\n\n    // Build the stack, one array per item, with an elem for each quarter\n    const stack = d3\n      .stack()\n      .keys(this.Z)\n      .value(([, group], key) => {\n        const item = group.get(key);\n        const total = this.totals.get(item.x);\n        return item && item.y && total ? item.y / total : 0;\n      })(indexed);\n\n    // Largest items are returned first, since the stack are all drawn from zero\n    return stack.reverse();\n  }\n\n  get yDomain() {\n    // Share charts will always be 0 to 1.0\n    return [0.0, 1.0];\n  }\n}\n\nexport function TimeSeriesBarShares(data, parser) {\n  return new TimeSeriesBarSharesChart(data, parser);\n}\n", "import * as d3 from \"d3\";\n\nexport const month = d3.utcFormat(\"%b\");\nexport const monthDay = d3.utcFormat(\"%b %-d\");\nexport const monthYear = d3.utcFormat(\"%b %Y\");\nexport const monthDayYear = d3.utcFormat(\"%b %-d, %Y\");\nexport const fullMonthDayYear = d3.utcFormat(\"%B %-d, %Y\");\n\nexport function makeDateFormatter() {\n  let lastYear = null;\n  return function (d) {\n    const year = d.getUTCFullYear();\n    if (lastYear !== year) {\n      lastYear = year;\n      return monthDayYear(d);\n    }\n    return monthDay(d);\n  };\n}\n\nexport function makeMonthlyDateFormatter() {\n  let lastYear = null;\n  return function (d) {\n    const year = d.getUTCFullYear();\n    if (lastYear !== year) {\n      lastYear = year;\n      return monthYear(d);\n    }\n    return month(d);\n  };\n}\n\nexport function quarter(d) {\n  // Format a Date as a quarter and year\n  const q = parseInt(d.getUTCMonth() / 3) + 1;\n  return `${q}Q ${d.getUTCFullYear()}`;\n}\n\nexport const year = (d) => d.getUTCFullYear();\n\nexport function quarterToIso(value) {\n  // Convert a quarter in the format (q)Q(yyyy) - e.g. 1Q2024 - to an ISO date\n  value = String(value).replace(\" \", \"\");\n  let year = \"\";\n  if (value.length === 4) {\n    year = `20${value.substring(2)}`;\n  } else if (value.length === 6) {\n    year = value.substring(2);\n  }\n  if (!year) return null;\n  let q = parseInt(value.substring(0, 1));\n  let month = `${q * 3}`.padStart(2, \"0\");\n  let day = [\"\", \"31\", \"30\", \"30\", \"31\"][q];\n  return d3.isoParse(`${year}-${month}-${day}`);\n}\n\nexport function yearToIso(value) {\n  // Convert a year to an ISO date\n  if (value.length !== 4) return null;\n  const year = parseInt(value);\n  return d3.isoParse(`${year}-01-01`);\n}\n\nexport function unixDateRange(start, end) {\n  // Return an inclusive array of all dates from start to end\n  return d3.unixDay.range(start, d3.unixDay.offset(end, 1));\n}\n", "import * as d3 from \"d3\";\n\nimport { animatedDashArray, animatedDashOffset } from \"./animation\";\nimport { Chart } from \"./chart\";\nimport { volume } from \"./formats\";\nimport { layoutSVG } from \"./layout\";\nimport { parseArrayOHLCV, parseVerboseOHLCV } from \"./parsers\";\nimport { throttle } from \"./throttle\";\nimport {\n  maxLabelSize,\n  filterTicksAutoOffset,\n  invertBand,\n  zoomRange,\n} from \"./ticks\";\nimport { makeDateFormatter } from \"./timeseries\";\nimport { placeTooltip, placeTooltipTop } from \"./tooltip\";\n\nexport { parseArrayOHLCV, parseVerboseOHLCV, placeTooltip, placeTooltipTop };\n\n// Clip paths require a unique ID\nlet uniqueID = 0;\n\nfunction signOf(d) {\n  // TODO Assumes both open and close are defined\n  return 1 + Math.sign(d.o - d.c);\n}\n\nconst classes = [\"up\", \"even\", \"down\"];\n\nfunction deltaClass(d) {\n  // Return's a class depending on the day's delta\n  return classes[signOf(d)];\n}\n\nfunction extentData(data, start = 0, end) {\n  // Calculate the extent of the price data, optionally with a slice of the data\n  if (end) {\n    data = data.slice(start, end + 1);\n  }\n  const minY = d3.min(d3.map(data, (d) => d.l));\n  return [minY, d3.max(d3.map(data, (d) => d.h))];\n}\n\nexport class CandlestickChart extends Chart {\n  // Allow a custom formatting of prices, setting null will use default formats\n  priceFormat = d3.format(\",~f\");\n\n  // CandlestickChart expects data in the format [{x, o, h, l, c, v}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      VOLUME_RATIO: 0.0,\n      LOG_Y: false, // We need to know which scale is used for proper tick formats\n      BAND_PAD: 0.1,\n      FPS: 48,\n      DURATION_MS: 750,\n      DELAY_MS: 0,\n      DELAY_ONCE: false,\n      DISABLE_BRUSH: false,\n      PRICE_AXIS_RIGHT: false,\n      VOLUME_AXIS_RIGHT: true,\n      HIDE_VOLUME_AXIS: false,\n      VOLUME_TICK_COUNT: 1,\n      RESCALE_Y: true,\n      CLAMP: false, // Axes clamps are disabled by default\n      LAYOUT: {},\n      OVERFLOW: false, // Allow overflow of the SVG element\n\n      // For rendered lines\n      STROKE_WIDTH: 1.5,\n\n      // Additional layout padding\n      // TODO Specify an additional layout?\n      MARGIN_RIGHT: 10,\n      MARGIN_LEFT: 10,\n      MARGIN_LABEL: 10,\n      MARGIN_AXES: 5,\n      MARGIN_TICK: 2,\n    };\n\n    this.opened = false; // Set true after the initial animation\n\n    // Get data in a {x, o, h, l, c, v} format\n    this.data = d3.map(data, parser);\n\n    // Config and rendered elements for lines\n    this.lines = {};\n    this.lineElements = {};\n\n    // Also save the X axis, since it is used for filtering tick labels\n    this.X = d3.map(this.data, (d) => d.x);\n\n    // Zoom works by setting the start and end indices\n    // By default, all data is shown\n    this.start = 0;\n    this.end = this.data.length - 1;\n  }\n\n  /* Config chained methods */\n  doNotRescaleY() {\n    // Do not rescale the Y axis on zoom\n    this.config.RESCALE_Y = false;\n    return this;\n  }\n\n  bandPadding(value) {\n    this.config.BAND_PAD = value;\n    return this;\n  }\n\n  priceAxisRight() {\n    // The price axis ticks and labels will be shown on the right of the chart\n    this.config.PRICE_AXIS_RIGHT = true;\n    return this;\n  }\n\n  showVolume(ratio = 0.1) {\n    // TODO Allow to be called dynamically?\n    this.config.VOLUME_RATIO = ratio;\n    return this;\n  }\n\n  hideVolume() {\n    // TODO Allow to be called dynamically?\n    return this.showVolume(0.0);\n  }\n\n  hideVolumeAxis() {\n    // The volume chart will still be shown, but without a label\n    this.config.HIDE_VOLUME_AXIS = true;\n    return this;\n  }\n\n  volumeTickCount(value = 1) {\n    // Number of volume axis ticks that should be shown\n    this.config.VOLUME_TICK_COUNT = value;\n    return this;\n  }\n\n  defaultLog() {\n    this.config.LOG_Y = true;\n    return this;\n  }\n\n  defaultLinear() {\n    this.config.LOG_Y = false;\n    return this;\n  }\n\n  disableZoom() {\n    // Do not trigger zoom on brush events\n    this.config.DISABLE_BRUSH = true;\n    return this;\n  }\n\n  enableClamp() {\n    this.config.CLAMP = true;\n    return this;\n  }\n\n  disableClamp() {\n    this.config.CLAMP = false;\n    return this;\n  }\n\n  staggerOpening(value = 0) {\n    // Stagger only the opening animation\n    this.config.DELAY_ONCE = true;\n    return this.staggerAnimation(value);\n  }\n\n  staggerAnimation(value = 0) {\n    // If not value is provided, stagger by a fraction of the total animation\n    if (!value && this.X.length) {\n      value = this.config.DURATION_MS / (2 * this.X.length);\n    }\n    this.config.DELAY_MS = value;\n    return this;\n  }\n\n  noStaggerAnimation() {\n    this.config.DELAY_MS = 0;\n    return this;\n  }\n  /* End config chained methods */\n\n  duration(d, i) {\n    if (this.config.DELAY_ONCE && this.opened) {\n      return this.config.DURATION_MS;\n    }\n    return this.config.DURATION_MS / 2;\n  }\n\n  delay(d, i) {\n    return this.config.DELAY_ONCE && this.opened ? 0 : i * this.config.DELAY_MS;\n  }\n\n  get volumeAxesIsVisible() {\n    return Boolean(this.config.VOLUME_RATIO) && !this.config.HIDE_VOLUME_AXIS;\n  }\n\n  get volumeAxesVisibility() {\n    return this.volumeAxesIsVisible ? \"visible\" : \"hidden\";\n  }\n\n  get priceTickFormat() {\n    // Linear axes can use the priceFormat directly, but log axes need additional config\n    if (this.config.LOG_Y) {\n      const numTicks = d3.max([this.scaleLinear.ticks().length, 2]);\n      return this.scaleLog.tickFormat(numTicks, this.priceFormat);\n    } else {\n      return this.priceFormat;\n    }\n  }\n\n  get priceAxisIndex() {\n    if (this.config.PRICE_AXIS_RIGHT) {\n      return d3.axisRight(this.scaleY).tickFormat(this.priceTickFormat);\n    }\n    return d3.axisLeft(this.scaleY).tickFormat(this.priceTickFormat);\n  }\n\n  get gridWidth() {\n    return -this.layout.innerWidth - this.config.MARGIN_AXES;\n  }\n\n  get wickThickness() {\n    // Wick thickness should at least 1px, but no greater than 3% of the band or 10px\n    return d3.min([d3.max([this.scaleX.bandwidth() * 0.03, 1.0]), 10]);\n  }\n\n  makeDateFormatter() {\n    return makeDateFormatter();\n  }\n\n  get xValues() {\n    return filterTicksAutoOffset(\n      this.X.slice(this.start, this.end + 1),\n      this.layout,\n      this.labelWidthX,\n    );\n  }\n\n  updateLayout() {}\n\n  addLineAbove(name, color = \"currentColor\", pattern, strokeWidth) {\n    return this.addLine(name, color, true, pattern, strokeWidth);\n  }\n\n  addLineBelow(name, color = \"currentColor\", pattern, strokeWidth) {\n    return this.addLine(name, color, false, pattern, strokeWidth);\n  }\n\n  addLine(name, color = \"currentColor\", above = false, pattern, strokeWidth) {\n    // Add a new line to the chart - the key must match a property in the data elements\n    this.lines[name] = {\n      color: color,\n      above: above,\n      pattern: pattern,\n      strokeWidth: strokeWidth || this.config.STROKE_WIDTH,\n    };\n    return this;\n  }\n\n  // Line methods - all methods return the line's path D3 element\n  getLine(name) {\n    return this.lineElements[name];\n  }\n\n  setLineOpacity(name, opacity = 1.0) {\n    return this.getLine(name).attr(\"opacity\", opacity);\n  }\n\n  showLine(name) {\n    return this.setLineOpacity(name, 1.0);\n  }\n\n  hideLine(name) {\n    return this.setLineOpacity(name, 0);\n  }\n\n  moveLineBelow(name) {\n    const path = this.getLine(name);\n    this.lineBelow.append(() => path.node().parentNode);\n    return path;\n  }\n\n  moveLineAbove(name) {\n    const path = this.getLine(name);\n    this.lineAbove.append(() => path.node().parentNode);\n    return path;\n  }\n\n  renderLine(name, x, y) {\n    // Adds a line to be rendered. The name should match the key in the data object\n    const config = this.lines[name];\n    const g = config.above\n      ? this.lineAbove.append(\"g\")\n      : this.lineBelow.append(\"g\");\n    const grouping = d3.group(this.data, () => name);\n\n    const line = d3\n      .line()\n      .digits(3)\n      .defined((d) => d.x && d[name])\n      .x((d) => x(d.x) + x.step() / 2)\n      .y((d) => y(d[name]));\n\n    const path = g\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", config.strokeWidth)\n      .attr(\"stroke\", config.color)\n      .attr(\"opacity\", 1)\n      .selectAll(\"path\")\n      .data(grouping)\n      .join(\"path\")\n      .attr(\"d\", ([, I]) => line(I));\n\n    this.lineElements[name] = path;\n    return path;\n  }\n\n  updateLine(name, x, y) {\n    const path = this.getLine(name);\n    const config = this.lines[name];\n    const p = config.pattern || [];\n\n    const line = d3\n      .line()\n      .digits(3)\n      .defined((d) => d.x && d[name])\n      .x((d) => x(d.x) + x.step() / 2)\n      .y((d) => y(d[name]));\n\n    // If a path was previously updated, remove the offset and set its pattern\n    if (this.opened) {\n      path\n        .attr(\"stroke-dasharray\", p.length ? p.join(\" \") : null)\n        .attr(\"stroke-dashoffset\", 0); // NOTE should already be 0, but just in case\n    }\n\n    const transition = path.transition().duration(this.config.DURATION_MS);\n    transition.attr(\"d\", ([, I]) => line(I));\n\n    // If a path hasn't been previously updated, add its opening animation\n    if (!this.opened) {\n      const l = Math.ceil(path.node().getTotalLength());\n      path.attr(\"stroke-dasharray\", animatedDashArray(config.pattern, l));\n      transition.attrTween(\"stroke-dashoffset\", () => animatedDashOffset(p, l));\n    }\n    return path;\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // Set a new clip path ID whenever the chart is rendered\n    const clipPathID = `candlestick-clip-path-${uniqueID++}`;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(\n      selector,\n      this.config.LAYOUT,\n      this.config.OVERFLOW,\n    );\n\n    // The price and volume portions of the chart will share an x-axis\n    const volumeHeight = this.layout.innerHeight * this.config.VOLUME_RATIO;\n    const priceHeight = this.layout.innerHeight - volumeHeight;\n\n    const maxVolume = d3.max(d3.map(this.data, (d) => d.v));\n\n    this.scaleVolume = d3\n      .scaleLinear()\n      .domain([0, maxVolume])\n      .range([volumeHeight, 0])\n      .clamp(this.config.CLAMP)\n      .nice();\n\n    // Right pad the volume ticks\n    if (this.volumeAxesIsVisible) {\n      const [volWidth, volHeight] = maxLabelSize(\n        this.svg,\n        this.layout,\n        this.scaleVolume.copy(),\n        volume,\n        \"v axis\",\n      );\n      this.layout.pad.right = volWidth + this.config.MARGIN_RIGHT;\n    }\n\n    let domainY = extentData(this.data);\n    const minY = domainY[0];\n    const rangeY = [priceHeight, 0];\n\n    // Axes\n    this.scaleLinear = d3\n      .scaleLinear()\n      .domain(domainY)\n      .range(rangeY)\n      .clamp(this.config.CLAMP);\n\n    this.scaleLog = d3\n      .scaleLog()\n      .domain(domainY)\n      .range(rangeY)\n      .clamp(this.config.CLAMP);\n\n    // Get the max tick label width for the y-axis on both linear and log scales\n    const [logWidth, logHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.scaleLog.copy(),\n      this.priceFormat,\n      \"y axis\",\n    );\n    const [linearWidth, linearHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.scaleLinear.copy(),\n      this.priceFormat,\n      \"y axis\",\n    );\n    const labelWidthY = d3.max([logWidth, linearWidth]);\n\n    // Left pad the the y-axis labels\n    // TODO Option for additional padding\n    if (this.config.PRICE_AXIS_RIGHT) {\n      this.layout.pad.left = this.config.MARGIN_LEFT;\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        labelWidthY + this.config.MARGIN_RIGHT,\n      ]);\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        labelWidthY + this.config.MARGIN_LEFT,\n      ]);\n    }\n\n    // Create a clip path for the inner data element to hide any overflow content\n    this.svg\n      .append(\"defs\")\n      .append(\"clipPath\")\n      .attr(\"id\", clipPathID)\n      .append(\"rect\")\n      .attr(\"width\", this.layout.innerWidth)\n      .attr(\"height\", this.layout.innerHeight);\n\n    // Set the inner display\n    this.inner = this.svg\n      .append(\"g\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    this.scaleX = d3\n      .scaleBand(this.X, [0, this.layout.innerWidth])\n      .paddingInner(this.config.BAND_PAD)\n      .paddingOuter(this.config.BAND_PAD / 2);\n\n    // NOTE The date formatter needs to be created because it uses a\n    // closure to determine a new year\n    // TODO Reset the date formatter whenever the x-axis is called\n    let dates = this.makeDateFormatter();\n\n    // Get the max tick label width for the x-axis\n    const [labelWidthX, labelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.scaleX.copy(),\n      dates,\n      \"x axis\",\n    );\n    this.labelWidthX = labelWidthX + this.config.MARGIN_LABEL;\n\n    let yTransform = \"transform(0,0)\";\n    if (this.config.PRICE_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.innerWidth + this.config.MARGIN_AXES},0)`;\n    }\n\n    // Reset the date formatter\n    dates = this.makeDateFormatter();\n\n    // Set the zero state\n    this.scaleY = this.config.LOG_Y ? this.scaleLog : this.scaleLinear;\n    const axisY = this.priceAxisIndex;\n\n    this.grid = this.inner\n      .append(\"g\")\n      .attr(\"transform\", yTransform)\n      .attr(\"class\", \"grid\")\n      .call(axisY.tickSize(this.gridWidth));\n\n    this.axisX = d3\n      .axisBottom(this.scaleX)\n      .tickValues(this.xValues)\n      .tickFormat(dates)\n      .tickSize(4);\n\n    this.gPrice = this.inner\n      .append(\"g\")\n      .attr(\"transform\", yTransform)\n      .attr(\"class\", \"y axis\")\n      .call(axisY.tickSize(0));\n\n    // Volume elements are always rendered even if their height is zero\n    this.axisVolume = d3\n      .axisRight(this.scaleVolume)\n      .ticks(this.config.VOLUME_TICK_COUNT)\n      .tickFormat(volume)\n      .tickSize(3);\n\n    this.volume = this.inner\n      .append(\"g\")\n      .attr(\"class\", \"volume\")\n      .attr(\n        \"transform\",\n        `translate(0,${this.layout.innerHeight - volumeHeight})`,\n      );\n\n    this.gVolume = this.volume\n      .append(\"g\")\n      .attr(\"class\", \"v axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.innerWidth + this.config.MARGIN_TICK},0)`,\n      )\n      .call(this.axisVolume)\n      .attr(\"visibility\", this.volumeAxesVisibility);\n\n    this.volumeSlots = this.volume\n      .append(\"g\")\n      .attr(\"clip-path\", `url(#${clipPathID})`)\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-linecap\", \"butt\") // NOTE using 'square' distorts size\n      .selectAll(\"g\")\n      .data(this.data)\n      .join(\"g\")\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.bandwidth() / 2},0)`,\n      );\n\n    this.volumeBars = this.volumeSlots\n      .append(\"line\")\n      .attr(\"y1\", this.scaleVolume(0))\n      .attr(\"y2\", this.scaleVolume(0))\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"class\", deltaClass);\n\n    // For rendering lines underneath the candlesticks\n    this.lineBelow = this.inner\n      .append(\"g\")\n      .attr(\"clip-path\", `url(#${clipPathID})`)\n      .attr(\"class\", \"lineBelow\");\n\n    this.price = this.inner.append(\"g\").attr(\"class\", \"price\");\n\n    this.candles = this.price\n      .append(\"g\")\n      .attr(\"clip-path\", `url(#${clipPathID})`)\n      .attr(\"stroke-linecap\", \"butt\") // NOTE using 'square' distorts size\n      .attr(\"stroke\", \"currentColor\")\n      .selectAll(\"g\")\n      .data(this.data)\n      .join(\"g\")\n      .attr(\"class\", deltaClass)\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.bandwidth() / 2},0)`,\n      );\n\n    this.wicks = this.candles\n      .append(\"line\")\n      .attr(\"stroke-width\", this.wickThickness)\n      .attr(\"class\", \"wick\")\n      .attr(\"y1\", this.scaleY(minY))\n      .attr(\"y2\", this.scaleY(minY));\n\n    this.bars = this.candles\n      .append(\"line\")\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"class\", \"bar\")\n      .attr(\"y1\", this.scaleY(minY))\n      .attr(\"y2\", this.scaleY(minY));\n\n    // For rendering line above the candlesticks\n    this.lineAbove = this.inner\n      .append(\"g\")\n      .attr(\"clip-path\", `url(#${clipPathID})`)\n      .attr(\"class\", \"lineAbove\");\n\n    // Elements drawn last will appear on top\n    this.gx = this.inner\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\"transform\", `translate(0,${this.layout.innerHeight})`)\n      .call(this.axisX);\n\n    // Draw any lines\n    for (let key in this.lines) {\n      this.renderLine(key, this.scaleX, this.scaleY);\n    }\n\n    // Brush for zoom\n    this.brush = d3.brushX().extent([\n      [0, 0],\n      [this.layout.innerWidth, this.layout.innerHeight],\n    ]);\n\n    this.gBrush = this.inner.append(\"g\").attr(\"class\", \"brush\");\n\n    if (!this.config.DISABLE_BRUSH) {\n      this.brush.on(\"end\", this.zoom.bind(this));\n      this.gBrush.call(this.brush.bind(this));\n    }\n\n    // Optional spotlight of a bar\n    // Don't call the class \"tooltip\" - that interferes with Bootstrap\n    this.spotlightBar = this.inner\n      .append(\"g\")\n      .lower() // The spotlight should always be the lowest layer of the SVG\n      .attr(\"class\", \"spotlight\")\n      .append(\"rect\")\n      .style(\"display\", \"none\")\n      .style(\"pointer-events\", \"none\");\n\n    // Set the initial prices with the default axes\n    this.update();\n  }\n\n  update() {\n    // Update the chart to start and end on the given x-axis indices\n    // The y-axis will also be updated to the min and max of the data for the given xs\n    const zRange = zoomRange(\n      this.scaleX.domain(),\n      this.layout.innerWidth,\n      this.start,\n      this.end,\n    );\n\n    // Do not update the domain - just the range\n    this.scaleX.range(zRange);\n\n    // Update the axisY according to the new min and max of the data\n    if (this.config.RESCALE_Y) {\n      let domainY = extentData(this.data, this.start, this.end);\n      this.scaleLinear.domain(domainY);\n      this.scaleLog.domain(domainY); // TODO .nice() can be called here\n    }\n\n    this.scaleY = this.config.LOG_Y ? this.scaleLog : this.scaleLinear;\n    const axisY = this.priceAxisIndex;\n\n    // Reset the date formatter and re-filter the X-axis date labels\n    const dates = this.makeDateFormatter();\n    this.axisX.tickValues(this.xValues).tickFormat(dates);\n\n    // Update the x-axis\n    this.gx\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"transform\", `translate(0,${this.layout.innerHeight})`)\n      .call(this.axisX);\n\n    // Update the y-axis\n    this.gPrice\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(axisY.tickSize(0));\n\n    // Update the grid\n    this.grid\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(axisY.tickFormat(\"\").tickSize(this.gridWidth));\n\n    // Update the candles\n    this.candles\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.bandwidth() / 2},0)`,\n      );\n\n    this.bars\n      .transition()\n      .delay(this.delay.bind(this))\n      .duration(this.duration.bind(this))\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"y1\", (d) => this.scaleY(d.o))\n      .attr(\"y2\", (d) => this.scaleY(d.c));\n\n    this.wicks\n      .transition()\n      .delay(this.delay.bind(this))\n      .duration(this.duration.bind(this))\n      .attr(\"stroke-width\", this.wickThickness)\n      .attr(\"y1\", (d) => this.scaleY(d.l))\n      .attr(\"y2\", (d) => this.scaleY(d.h));\n\n    // Hide the spotlight on update - it will reactivate on next hover\n    this.noSpotlight();\n\n    // Update the spotlight width\n    this.spotlightBar\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"width\", this.scaleX.step());\n\n    // Update the volume\n    this.volumeSlots\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\n        \"transform\",\n        (d) => `translate(${this.scaleX(d.x) + this.scaleX.bandwidth() / 2},0)`,\n      );\n\n    this.volumeBars\n      .transition()\n      .delay(this.delay.bind(this))\n      .duration(this.duration.bind(this))\n      .attr(\"stroke-width\", this.scaleX.bandwidth())\n      .attr(\"y2\", (d) => this.scaleVolume(d.v || 0));\n\n    // Update any lines\n    for (let key in this.lines) {\n      this.updateLine(key, this.scaleX, this.scaleY);\n    }\n\n    this.opened = true;\n  }\n\n  zoom({ selection }) {\n    if (!selection) return;\n    // Get the closest indices to the selection\n    const [x0, x1] = selection;\n    [this.start, this.end] = [\n      invertBand(this.scaleX, x0),\n      invertBand(this.scaleX, x1),\n    ];\n    this.update();\n\n    // Reset the brush\n    this.gBrush.call(this.brush.move, null);\n  }\n\n  reset() {\n    this.start = 0;\n    this.end = this.data.length - 1;\n    this.update();\n  }\n\n  useLog() {\n    this.config.LOG_Y = true;\n    this.update();\n  }\n\n  useLinear() {\n    this.config.LOG_Y = false;\n    this.update();\n  }\n\n  spotlight(index) {\n    // TODO We only need to pad if width is set to bandwidth instead of step\n    // const pad = this.scaleX.bandwidth() * this.scaleX.paddingInner() * 0.5;\n    const offset = this.scaleX.step() * this.scaleX.paddingOuter();\n    this.spotlightBar\n      .attr(\"x\", this.scaleX(this.data[index].x) - offset)\n      .attr(\"width\", this.scaleX.step())\n      .attr(\"y\", 0)\n      .attr(\"height\", this.layout.innerHeight)\n      .style(\"display\", \"block\");\n  }\n\n  noSpotlight() {\n    this.spotlightBar.style(\"display\", \"none\");\n  }\n\n  onEvent(move, leave) {\n    // Enable events for the chart. On move, determine which band is being\n    // hovered over and send an object of its OHLCV data to the move callback.\n    // The leave callback is triggered when the pointer leaves the SVG elem.\n    let prevIndex = null;\n\n    const pointermove = (evt) => {\n      if (evt.touches) {\n        // Prevent scroll on touch devices\n        evt.preventDefault();\n        evt = evt.touches[0];\n      }\n      const [xm] = d3.pointer(evt);\n      const index = invertBand(this.scaleX, xm - this.layout.pad.left);\n\n      // TODO To only trigger the callback when the index changes\n      // if (prevIndex && prevIndex == index) {\n      //   return;\n      // }\n\n      prevIndex = index;\n\n      // Include the index's OHLCV data and a change from the last close\n      let data = structuredClone(this.data[index]);\n      data.index = index;\n\n      [data.px, data.py] = d3.pointer(evt, null);\n\n      if (index > 0) {\n        const prev = this.data[index - 1];\n        if (prev && prev.c) {\n          data.prev = prev.c;\n          data.delta = data.c - prev.c;\n          data.percent = data.delta / prev.c;\n        }\n      }\n\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      prevIndex = null;\n      if (leave) {\n        leave.call(this, evt);\n      }\n    };\n\n    this.svg\n      .on(\"mousemove\", throttle(pointermove, 1000.0 / this.config.FPS))\n      .on(\"mouseleave\", pointerleave)\n      .on(\"touchstart\", pointermove, { passive: false })\n      .on(\"touchmove\", throttle(pointermove, 1000.0 / this.config.FPS), {\n        passive: false,\n      })\n      .on(\"touchend\", pointerleave, { passive: false });\n  }\n\n  // TODO method to append a data point\n  append() {}\n}\n\nexport function OHLC(data, parser) {\n  return new CandlestickChart(data, parser);\n}\n\nexport function OHLCV(data, parser) {\n  return new CandlestickChart(data, parser).showVolume();\n}\n", "import * as d3 from \"d3\";\n\nexport const percent = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 0,\n  maximumFractionDigits: 2,\n}).format;\n\nexport const percentChange = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n  signDisplay: \"exceptZero\",\n}).format;\n\nexport const magnitude = new Intl.NumberFormat(\"en-US\", {\n  notation: \"compact\",\n  compactDisplay: \"short\",\n  minimumFractionDigits: 1,\n  maximumFractionDigits: 2,\n}).format;\n\nexport const units = d3.format(\",.0f\");\n\nexport const price = d3.format(\",.2f\");\n\nexport const volume = function (value) {\n  if (!value) return; // Never show 0\n  if (value >= 1e9) return `${value / 1e9}B`; // Billions\n  if (value >= 1e6) return `${value / 1e6}M`; // Millions\n  return units(value);\n};\n", "/*\nLine chart\n*/\nimport * as d3 from \"d3\";\n\nimport { animatedDashArray, animatedDashOffset } from \"./animation\";\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { throttle } from \"./throttle\";\nimport { maxLabelSize } from \"./ticks\";\nimport { placeTooltip, placeTooltipTop, pageXY } from \"./tooltip\";\n\nexport { parse3dArray, parseTimeSeries3dArray, placeTooltip, placeTooltipTop };\n\n// Clip paths require a unique ID\nlet uniqueID = 0;\n\nfunction getLength(elem) {\n  // Not all DOMs support getTotalLength\n  return elem.getTotalLength ? elem.getTotalLength() : null;\n}\n\nexport class LineChart extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Line charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      LAYOUT: {},\n      DURATION_MS: 500,\n      FPS: 48,\n      Y_AXIS_RIGHT: false,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      HIGHLIGHT_STROKE_WIDTH: 2.0, // Width when highlighted\n      STROKE_WIDTH: 1.5, // Width when not highlighted\n      DOT_RADIUS: 3.0, // Radius of the dot\n      HIDE_EMPTY_CHART: false,\n      COLORS: d3.schemeCategory10, // TODO There's no way to change the default yet\n      OVERFLOW: false, // Allow overflow of the SVG element\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    this.patterns = {}; // {z: dash array pattern}\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Chained config methods */\n  setPattern(z, pattern) {\n    // Set the dash array pattern for a z item\n    this.patterns[z] = pattern;\n    return this;\n  }\n\n  hideIfEmpty() {\n    this.config.HIDE_EMPTY_CHART = true;\n    return this;\n  }\n  /* End chained config methods */\n\n  getPattern(z) {\n    // Returns an array of the z item pattern, with unset patterns as an empty array\n    return this.patterns[z] || [];\n  }\n\n  getDashArrayAttr(z) {\n    // Return the z item pattern as a string or null\n    return this.getPattern(z).length ? this.getPattern(z).join(\" \") : null;\n  }\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.Z, (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get zVisible() {\n    const visible = new d3.InternSet(this.Z);\n    this.hidden.forEach((z) => visible.delete(z));\n    return Array.from(visible);\n  }\n\n  get visibleData() {\n    // TODO memoization\n    return d3.filter(this.data, (d) => !this.hidden.has(d.z));\n  }\n\n  get empty() {\n    // Returns True if there are no visible items on the chart\n    return this.zVisible.length === 0;\n  }\n\n  get xDomain() {\n    // By default, don't re-calculate the x-axis\n    return d3.extent(d3.map(this.data, (d) => d.x));\n  }\n\n  get yDomain() {\n    // TODO memoization\n    if (this.visibleData.length) {\n      return d3.extent(d3.map(this.visibleData, (d) => d.y));\n    } else {\n      return d3.extent(d3.map(this.data, (d) => d.y));\n    }\n  }\n\n  get xScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0]);\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(3).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    if (this.config.Y_AXIS_RIGHT) {\n      g.call(d3.axisRight(y).tickSize(0).tickFormat(this.yFormat));\n    } else {\n      g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n    }\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    // Another option for \"zero state\" is to set the tick size to zero\n    // const tickSize = this.empty ? 0 : -this.layout.innerWidth;\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"))\n      .selectAll(\".tick\")\n      .each(function (d) {\n        d3.select(this).classed(\"zero\", d === 0);\n      });\n    // The following throws an error:\n    // .classed(\"zero\", d => d === 0)\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    if (this.config.Y_AXIS_RIGHT) {\n      this.layout.pad.right = d3.max([\n        this.layout.pad.right,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n      // The default axes has a pretty large left pad - if using a right axes this\n      // left pad can be reduced\n      this.layout.pad.left = 5;\n    } else {\n      this.layout.pad.left = d3.max([\n        this.layout.pad.left,\n        yLabelWidth + this.config.MARGIN_TICK + 5,\n      ]);\n    }\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(\n      selector,\n      this.config.LAYOUT,\n      this.config.OVERFLOW,\n    );\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    this.x = this.xScale;\n    this.y = this.yScale;\n\n    // Start with the SVG visible - this can be set to 0 for \"fade in\"\n    this.svg.attr(\"opacity\", 1.0);\n\n    // First items drawn are lower layers\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    this.gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    let yTransform = `translate(${this.layout.pad.left - this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    if (this.config.Y_AXIS_RIGHT) {\n      yTransform = `translate(${this.layout.pad.left + this.layout.innerWidth + this.config.MARGIN_TICK},${this.layout.pad.top})`;\n    }\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\"transform\", yTransform);\n\n    const grouping = d3.group(this.data, (d) => d.z);\n\n    this.paths = this.gInner\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH)\n      .selectAll(\"path\")\n      .data(grouping)\n      .join(\"path\");\n\n    // Dot - shows nearest point during pointer events\n    this.dot = this.gInner\n      .append(\"g\")\n      .attr(\"class\", \"dot\")\n      .style(\"display\", \"none\");\n    this.circle = this.dot.append(\"circle\").attr(\"r\", this.config.DOT_RADIUS);\n\n    // The initial line drawing animation relies on manipulating stroke attributes,\n    // which can change whenever we redraw lines, so we'll only do the draw animation\n    // once and all subsequent updates will just use a solid stroke\n    this.previousUpdate = false;\n\n    // Visibility and opacity will be changed when the chart is in a \"zero state\"\n    const isEmpty = this.empty;\n\n    // Set initial state\n    this.gx.call(this.xAxis.bind(this), this.x).attr(\"opacity\", 1.0);\n\n    this.gy\n      .call(this.yAxis.bind(this), this.y)\n      .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n\n    this.gGrid.call(this.grid.bind(this), this.x, this.y);\n\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => this.x(d.x))\n      .y((d) => this.y(d.y));\n\n    this.paths\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"stroke\", ([z]) => this.colors(z))\n      .attr(\"class\", ([z]) => className(z))\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n\n    this.update(this.x, this.y);\n  }\n\n  getDashArray(z, i, lengths, previousUpdate) {\n    // By default, the dasharray performs an opening animation\n    // Custom patterns can be specified with setPattern() or overriding getPattern()\n    const p = this.getPattern(z);\n    if (p && p.length) {\n      if (previousUpdate) return p.join(\" \");\n      return lengths[i] ? animatedDashArray(p, lengths[i]) : null;\n    }\n    if (previousUpdate) return \"1 0\";\n    return lengths[i] ? `${lengths[i]} ${lengths[i]}` : null;\n  }\n\n  getDashOffset(z, i, lengths) {\n    // TODO Option to reverse opening? Set to -length?\n    return animatedDashOffset(this.getPattern(z), lengths[i]);\n  }\n\n  update(x, y) {\n    this.hideDot();\n\n    const isEmpty = this.empty;\n\n    // Option to hide the chart if there's no visible data\n    if (this.config.HIDE_EMPTY_CHART) {\n      this.svg\n        .transition()\n        .duration(this.config.DURATION_MS)\n        .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n    }\n\n    // Re-draw the chart with the new x and y scales\n    // NOTE: with current setup, x-axis doesn't need to be updated\n    this.gx\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(this.xAxis.bind(this), x);\n\n    this.gy\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .call(this.yAxis.bind(this), y)\n      .attr(\"opacity\", isEmpty ? 0.0 : 1.0);\n\n    // Grid lines have a hardcoded opacity 1, so we need to use visibility to hide them\n    this.gGrid\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"visibility\", isEmpty ? \"hidden\" : \"visible\")\n      .call(this.grid.bind(this), x, y);\n\n    // Plot the line\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => x(d.x))\n      .y((d) => y(d.y));\n\n    // If paths were previously updated, remove the offset and set simple patterns\n    if (this.previousUpdate) {\n      this.paths\n        .attr(\"stroke-dasharray\", ([z]) => this.getDashArrayAttr(z))\n        .attr(\"stroke-dashoffset\", null);\n    }\n\n    const transition = this.paths\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n\n    if (!this.previousUpdate) {\n      // Initial opening animation\n      const lengths = d3.map(this.paths, (elem) => getLength(elem));\n\n      this.paths.attr(\"stroke-dasharray\", ([z], i) =>\n        this.getDashArray(z, i, lengths),\n      );\n\n      transition.attrTween(\"stroke-dashoffset\", ([z], i) =>\n        this.getDashOffset(z, i, lengths),\n      );\n    }\n    this.previousUpdate = true;\n  }\n\n  placeDot(index) {\n    // Place a dot at the given index\n    const d = this.data[index];\n    this.dot\n      .style(\"display\", null)\n      .attr(\"transform\", `translate(${this.x(d.x)},${this.y(d.y)})`);\n    this.circle.attr(\"fill\", this.colors(d.z));\n  }\n\n  hideDot() {\n    this.dot.style(\"display\", \"none\");\n  }\n\n  noHighlight() {\n    // Reset all lines to default\n    this.paths\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0))\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH);\n  }\n\n  highlight(z) {\n    // Hide paths that aren't the currently selected path\n    this.paths\n      .attr(\"opacity\", ([elem]) => {\n        if (this.hidden.has(elem)) return 0;\n        return elem === z ? 1.0 : this.config.BACKGROUND_OPACITY;\n      })\n      .attr(\"stroke-width\", ([elem]) =>\n        elem === z\n          ? this.config.HIGHLIGHT_STROKE_WIDTH\n          : this.config.STROKE_WIDTH,\n      );\n\n    // Raise the currently selected path so other lines are rendered underneath it\n    this.paths.filter(([elem]) => elem === z).raise();\n  }\n\n  onEvent(move, leave) {\n    // let prevIndex = null;\n\n    const pointermove = (evt) => {\n      if (evt.touches) {\n        // Prevent scroll on touch devices\n        evt.preventDefault();\n        evt = evt.touches[0];\n      }\n\n      // X and y scales use the inner element, which is padded\n      let [xm, ym] = d3.pointer(evt, this.gInner.node());\n\n      // Determine the closest point to the cursor\n      // TODO Points could be memoized based on hidden z items\n      const points = d3.map(this.data, (d) => {\n        if (this.hidden.has(d.z)) return null;\n        return Math.hypot(this.x(d.x) - xm, this.y(d.y) - ym);\n      });\n\n      const index = d3.leastIndex(points);\n      if (index === -1 || points[index] === null) return;\n\n      // Exit early if no point was found\n      if (typeof index === \"undefined\") return;\n\n      // TODO To only trigger the callback when the index changes\n      // if (prevIndex && prevIndex == index) return;\n\n      this.placeDot(index);\n\n      const d = this.data[index];\n\n      // Data that will be provided to the callback: include both the coordinates\n      // of the dot and the pointer, both in relation to the page\n      const [dx, dy] = pageXY(this.dot.node());\n      const [px, py] = d3.pointer(evt, null);\n\n      const data = {\n        x: d.x,\n        y: d.y,\n        z: d.z,\n        // Dot page coordinates\n        dx: dx,\n        dy: dy,\n        // Pointer page coordinates\n        px: px,\n        py: py,\n      };\n\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      this.hideDot();\n      if (leave) {\n        leave.call(this, evt);\n      }\n    };\n\n    // Separate mouse and touch events\n    this.svg\n      .on(\"mousemove\", throttle(pointermove, 1000.0 / this.config.FPS))\n      .on(\"mouseleave\", pointerleave)\n      .on(\"touchstart\", pointermove, { passive: false })\n      .on(\"touchmove\", throttle(pointermove, 1000.0 / this.config.FPS), {\n        passive: false,\n      })\n      .on(\"touchend\", pointerleave, { passive: false });\n  }\n\n  toggle() {\n    if (this.visibleData.length) {\n      // Recalculate the y-scale based on the non-hidden items\n      this.y = this.yScale;\n    } else {\n      // Set y-axis to zero\n      // We would need the last y-axis domain in order to prevent tick labels\n      // from changing during this transition\n      this.y = d3\n        .scaleLinear()\n        .domain(this.y.domain())\n        .range([this.layout.innerHeight, this.layout.innerHeight]);\n    }\n    this.update(this.x, this.y);\n  }\n}\n\nexport function Line(data, parser) {\n  return new LineChart(data, parser);\n}\n\nexport class TimeSeriesChart extends LineChart {\n  get xScale() {\n    // Never re-calculate the x-axis\n    return d3\n      .scaleUtc()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  sortData(data) {\n    data.sort((a, b) => a.x - b.x);\n    return data;\n  }\n\n  parseData(data, parser) {\n    // Sort timeseries data in ascending order\n    return this.sortData(super.parseData(data, parser));\n  }\n}\n\nexport function TimeSeries(data, parser) {\n  return new TimeSeriesChart(data, parser);\n}\n", "import * as d3 from \"d3\";\n\nexport function lowerBoundDigits(values, bound = 0.1) {\n  // How many significant digits are needed to represent the lower bound of values?\n  if (!values || !values.length) {\n    return null;\n  }\n  // Only works for positive values\n  const lowerBound = d3.quantile(values, bound);\n  if (lowerBound > 0) {\n    return parseInt(Math.floor(Math.log10(lowerBound)));\n  }\n  return null;\n}\n\nexport function divideData(data, value = 1.0) {\n  return d3.map(data, (d) => ({ ...d, y: d.y ? d.y / value : d.y }));\n}\n", "import * as d3 from \"d3\";\n\nexport class Options {\n  constructor(options = {}) {\n    this.ANIMATION_DURATION_MS = 500;\n\n    // Allow either max number of ticks OR spacing\n    this.SCREEN_HEIGHT_FRACTION = 0.65;\n    this.X_TICK_MAX_COUNT = null;\n    this.X_TICK_SPACE = 50; // TODO calculate largest tick space dynamically\n    this.X_TICK_SIZE = 4;\n    this.X_TICK_GUTTER = 3;\n    this.Y_TICK_MAX_COUNT = null;\n    this.Y_TICK_SPACE = 40;\n    this.Y_TICK_SIZE = 0;\n    this.Y_TICK_GUTTER = 5; // Space between tick label and grid\n    this.FONT_SIZE = \"13px\";\n    this.COLORS = d3.schemeCategory10;\n    this.MIN_Y_AT_ZERO = false;\n    this.Y_TICKS_RIGHT = false;\n\n    // OHLC\n    this.BAND_PAD = 0.2; // As a percentage of the band\n    this.VOLUME_OPACITY = 0.6;\n    this.OHLC_COLORS = [\"#1ebc8c\", \"#b2b2b2\", \"#f34d27\"]; // [up, no change, down]\n    this.VOLUME_COLORS = [\"#1ebc8c\", \"#b2b2b2\", \"#f34d27\"]; // [up, no change, down]\n    this.HIDE_VOLUME = false;\n    this.HIDE_VOLUME_TICKS = false;\n\n    // Line\n    this.STROKE_WIDTH = 1.5;\n    this.HIGHLIGHT_STROKE_WIDTH = 2.0;\n    this.BACKGROUND_OPACITY = 0.3; // When another line is highlighted\n    this.DOT_RADIUS = 3.0;\n\n    // Bar\n    this.BAR_STROKE_WIDTH = 0.0;\n\n    // Pie\n    this.INNER_RADIUS = 0.3;\n    this.OUTER_RADIUS = 0.8;\n\n    this.INNER_RADIUS_HOVER = 0.3;\n    this.OUTER_RADIUS_HOVER = 0.9;\n\n    // TODO POINTER MOVE FPS\n    this.EVENT_FPS = 48;\n\n    // Allow user to override any of the above defaults\n    Object.assign(this, options);\n  }\n\n  get eventLatency() {\n    return parseInt(1000 / this.EVENT_FPS);\n  }\n\n  get showVolumeTicks() {\n    return !(this.HIDE_VOLUME || this.HIDE_VOLUME_TICKS);\n  }\n\n  getYTickCount(height) {\n    let count = parseInt(height / this.Y_TICK_SPACE) + 1;\n    if (this.Y_TICK_MAX_COUNT && count > this.Y_TICK_MAX_COUNT) {\n      count = this.Y_TICK_MAX_COUNT;\n    }\n    return count;\n  }\n\n  getXTickCount(width) {\n    let count = parseInt(width / this.X_TICK_SPACE) + 1;\n    if (this.X_TICK_MAX_COUNT && count > this.X_TICK_MAX_COUNT) {\n      count = this.X_TICK_MAX_COUNT;\n    }\n    return count;\n  }\n}\n", "/*\nPie chart (or donut)\n*/\nimport * as d3 from \"d3\";\n\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray, parseArrayYZ } from \"./parsers\";\nimport { throttle } from \"./throttle\";\nimport { placeTooltip, placeTooltipTop } from \"./tooltip\";\n\nexport {\n  parse3dArray,\n  parseTimeSeries3dArray,\n  parseArrayYZ,\n  placeTooltip,\n  placeTooltipTop,\n};\n\nexport class PieChart extends CategoricalChart {\n  // Pie charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n\n    // Default config\n    this.config = {\n      LAYOUT: {},\n      DURATION_MS: 500,\n      INNER_RADIUS: 0.3,\n      OUTER_RADIUS: 0.8,\n      INNER_RADIUS_HOVER: 0.3,\n      OUTER_RADIUS_HOVER: 0.9,\n      BACKGROUND_OPACITY: 0.5, // Opacity when another slice is highlighted\n      START_ANGLE: 0,\n      END_ANGLE: 2 * Math.PI,\n      INITIAL_CLOSED: false,\n      SKIP_ENTER_ANIMATION: false,\n      COLORS: d3.schemeCategory10,\n      OVERFLOW: false, // Allow overflow of the SVG element\n    };\n\n    this.data = d3.map(data, parser);\n\n    this.X = Array.from(new d3.InternSet(d3.map(this.data, (d) => d.x)));\n    this.Z = Array.from(new d3.InternSet(d3.map(this.data, (d) => d.z)));\n\n    // Group data by x - these are the individual data sets that will render the pie\n    this.byX = d3.group(this.data, (d) => d.x);\n\n    this.colors = d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Config chained methods */\n  radii(inner, outer) {\n    // Set radii\n    this.config.INNER_RADIUS = inner;\n    this.config.OUTER_RADIUS = outer;\n    return this;\n  }\n\n  hoverRadii(inner, outer) {\n    // Set radii on hover\n    this.config.INNER_RADIUS_HOVER = inner;\n    this.config.OUTER_RADIUS_HOVER = outer;\n    return this;\n  }\n\n  angles(start, end) {\n    this.config.START_ANGLE = start;\n    this.config.END_ANGLE = end;\n    return this;\n  }\n\n  renderClosed() {\n    // The initial render of the pie chart will be all zero, aka closed\n    this.config.INITIAL_CLOSED = true;\n    return this;\n  }\n\n  skipEnterAnimation() {\n    this.config.SKIP_ENTER_ANIMATION = true;\n    return this;\n  }\n  /* End config chained methods */\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(new Set(this.Z), (d) => {\n      return { key: d, color: this.color(d) };\n    });\n  }\n\n  get outerRadius() {\n    return this.config.OUTER_RADIUS * (this.layout.innerMinimum / 2);\n  }\n\n  get innerRadius() {\n    return this.config.INNER_RADIUS * (this.layout.innerMinimum / 2);\n  }\n\n  get outerRadiusHover() {\n    return this.config.OUTER_RADIUS_HOVER * (this.layout.innerMinimum / 2);\n  }\n\n  get innerRadiusHover() {\n    return this.config.INNER_RADIUS_HOVER * (this.layout.innerMinimum / 2);\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(\n      selector,\n      this.config.LAYOUT,\n      this.config.OVERFLOW,\n    );\n\n    // By default, show the latest quarter of data\n    // TODO Option to change default - or just use update()?\n    const latest = this.X[this.X.length - 1];\n\n    this.pie = d3\n      .pie()\n      .sort(null)\n      .value((d) => d.y)\n      .startAngle(this.config.START_ANGLE)\n      .endAngle(this.config.END_ANGLE);\n\n    this.arc = d3\n      .arc()\n      .innerRadius(this.innerRadius)\n      .outerRadius(this.outerRadius);\n\n    // Radii when enlarged\n    this.arcEnlarge = d3\n      .arc()\n      .innerRadius(this.innerRadiusHover)\n      .outerRadius(this.outerRadiusHover);\n\n    const [midX, midY] = this.layout.midpoint;\n\n    this.slices = this.svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(${midX},${midY})`);\n\n    // Center value display\n    this.gDisplay = this.svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(${midX},${midY})`)\n      .attr(\"class\", \"display\")\n      .append(\"text\");\n\n    // Optional label\n    // this.slices\n    //   .append(\"text\")\n    //   .attr(\"class\", \"label\")\n    //   .attr(\"transform\", (d) => `translate(${this.arc.centroid(d)})`)\n    //   .text(d => this.getLabel(d));\n\n    if (!this.config.INITIAL_CLOSED) {\n      this.update(latest);\n    }\n  }\n\n  update(x) {\n    // Update the pie chart with the data at the given x value\n    const items = this.byX.get(x);\n\n    // TODO All Z items should be represented in the new data - it makes updates easier\n    const arcs = this.pie(items);\n    const path = this.slices.selectAll(\"path\").data(arcs, (d) => d.data.z);\n\n    // Need to use a closure because the attrTween uses this\n    const arc = this.arc;\n\n    // Update existing arcs\n    path\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attrTween(\"d\", function (d) {\n        const interpolate = d3.interpolate(this._current, d);\n        this._current = interpolate(0);\n        return (t) => arc(interpolate(t));\n      });\n\n    // Enter new arcs\n    path\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", \"slice\")\n      .attr(\"opacity\", 1.0)\n      .append(\"path\")\n      .attr(\"fill\", (d) => this.colors(d.data.z))\n      .each(function (d) {\n        this._current = d;\n      })\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attrTween(\"d\", (d) => {\n        if (this.config.SKIP_ENTER_ANIMATION) {\n          return () => arc(d);\n        }\n        const interpolate = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);\n        return (t) => arc(interpolate(t));\n      });\n  }\n\n  getLabel(d) {\n    // Custom method to return a label from the joined pie data\n    return \"\";\n  }\n\n  set display(value) {\n    this.gDisplay.text(value);\n  }\n\n  enlarge(z) {\n    this.slices\n      .selectAll(\"path\")\n      .filter((d) => d.data.z === z)\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", this.arcEnlarge);\n  }\n\n  reset() {\n    this.slices\n      .selectAll(\"path\")\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"d\", this.arc);\n  }\n\n  noHighlight() {\n    this.slices\n      .selectAll(\"g\")\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"opacity\", 1.0);\n  }\n\n  highlight(z) {\n    this.slices\n      .selectAll(\"g\")\n      .transition()\n      .duration(this.config.DURATION_MS)\n      .attr(\"opacity\", (d) =>\n        d.data.z === z ? 1.0 : this.config.BACKGROUND_OPACITY,\n      );\n  }\n\n  onEvent(enter, move, leave) {\n    const pointerenter = (evt, d) => {\n      if (enter) {\n        enter.call(this, d.data, evt);\n      }\n    };\n\n    const pointermove = (evt, d) => {\n      // Touch events keep the target where the touch event started\n      let target = evt.target;\n\n      if (evt.touches) {\n        evt.preventDefault(); // Prevent scroll on touch devices\n        evt = evt.touches[0];\n        // Get the element at the current touch event\n        target = document.elementFromPoint(evt.clientX, evt.clientY);\n        // If the target element doesn't have a parent or data, exit early\n        // This likely means it is a non-slice element\n        // TODO Trigger a pointerleave?\n        if (!target || !target.parentNode) return;\n        d = d3.select(target).datum();\n        if (!d || !d.data) return;\n      }\n\n      // TODO Why doesn't pageXY work with the rectangle?\n      const rect = target.getBoundingClientRect();\n      const [px, py] = d3.pointer(evt, null);\n\n      // TODO Return the centroid?\n\n      const data = {\n        x: d.data.x,\n        y: d.data.y,\n        z: d.data.z,\n        // Slice page coordinates\n        dx: rect.x + window.scrollX,\n        dy: rect.y + window.scrollY,\n        // Pointer page coordinates\n        px: px,\n        py: py,\n      };\n\n      if (move) {\n        move.call(this, data, evt);\n      }\n    };\n\n    const pointerleave = (evt, d) => {\n      if (leave) {\n        leave.call(this, d.data, evt);\n      }\n    };\n\n    this.slices\n      .selectAll(\"path\")\n      .on(\"mouseenter\", pointerenter)\n      .on(\"mousemove\", throttle(pointermove, 20.83))\n      .on(\"mouseleave\", pointerleave)\n      .on(\"touchstart\", pointerenter, { passive: false })\n      .on(\"touchmove\", throttle(pointermove, 20.83), { passive: false })\n      .on(\"touchend\", pointerleave, { passive: false });\n  }\n}\n\nexport function Donut(data, parser) {\n  return new PieChart(data, parser);\n}\n\nexport function Pie(data, parser) {\n  return new PieChart(data, parser).radii(0, 0.8).hoverRadii(0, 0.9);\n}\n\nexport function Gauge(data, parser) {\n  return new PieChart(data, parser)\n    .angles(-Math.PI * 0.65, Math.PI * 0.65)\n    .radii(0.5, 0.8)\n    .hoverRadii(0.55, 0.9);\n}\n", "/*\nLine chart with zoom\n*/\nimport * as d3 from \"d3\";\n\nimport { CategoricalChart } from \"./chart\";\nimport { layoutSVG } from \"./layout\";\nimport { parse3dArray, parseTimeSeries3dArray } from \"./parsers\";\nimport { className } from \"./text\";\nimport { throttle } from \"./throttle\";\nimport { maxLabelSize } from \"./ticks\";\nimport { placeTooltip, placeTooltipTop, pageXY } from \"./tooltip\";\n\nexport { parse3dArray, parseTimeSeries3dArray, placeTooltip, placeTooltipTop };\n\n// Clip paths require a unique ID\nlet uniqueID = 0;\n\nexport class LineChartWithZoom extends CategoricalChart {\n  xFormat = null;\n  yFormat = null;\n\n  // Line charts expect data is the format [{x, y, z}...]\n  // Specify a parser if your input data is in a different format\n  constructor(data, parser = (d) => d) {\n    super(data, parser);\n    // Default config\n    this.config = {\n      LAYOUT: {},\n      DURATION_MS: 500,\n      FPS: 48,\n      BACKGROUND_OPACITY: 0.3, // Opacity when another line is highlighted\n      HIGHLIGHT_STROKE_WIDTH: 2.0, // Width when highlighted\n      STROKE_WIDTH: 1.5, // Width when not highlighted\n      DOT_RADIUS: 3.0, // Radius of the dot\n      ZOOM_EXTENT: [0.5, 32],\n      COLORS: d3.schemeCategory10,\n      OVERFLOW: false, // Allow overflow of the SVG element\n\n      // Additional margins\n      MARGIN_TICK: 3,\n    };\n\n    this.data = this.parseData(data, parser);\n    this.items = this.parseItems(data);\n    this.Z = this.parseZ(data);\n    this.colors = this.setColors(data);\n  }\n\n  parseData(data, parser) {\n    return d3.map(data, parser);\n  }\n\n  parseItems(data) {\n    // By default, items will be built from unique z values. To specify the items\n    // instead (and optionally provide a color) override this method\n    return Array.from(new Set(d3.map(this.data, (d) => d.z)));\n  }\n\n  parseZ(data) {\n    return this.items;\n  }\n\n  setColors(data) {\n    return d3.scaleOrdinal().domain(this.Z).range(this.config.COLORS);\n  }\n\n  /* Config chained methods */\n  zoomExtent(min, max) {\n    this.config.ZOOM_EXTENT = [min, max];\n    return this;\n  }\n\n  disableZoom() {\n    return this.zoomExtent(1, 1);\n  }\n  /* End config chained methods */\n\n  get legend() {\n    // Return the z items along with their colors\n    return d3.map(this.Z, (d) => {\n      return { key: d, color: this.colors(d) };\n    });\n  }\n\n  get visibleData() {\n    // TODO memoization\n    return d3.filter(this.data, (d) => !this.hidden.has(d.z));\n  }\n\n  get xDomain() {\n    return d3.extent(d3.map(this.visibleData, (d) => d.x));\n  }\n\n  get yDomain() {\n    return d3.extent(d3.map(this.visibleData, (d) => d.y));\n  }\n\n  get xScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n\n  get yScale() {\n    return d3\n      .scaleLinear()\n      .domain(this.yDomain)\n      .range([this.layout.innerHeight, 0]);\n  }\n\n  get zoomIsDisabled() {\n    return this.config.ZOOM_EXTENT[0] === 1 && this.config.ZOOM_EXTENT[1] === 1;\n  }\n\n  defined(d, i) {\n    // By default, all points are considered to be defined\n    return true;\n  }\n\n  xAxis(g, x) {\n    g.call(d3.axisBottom(x).tickSize(3).tickFormat(this.xFormat));\n  }\n\n  yAxis(g, y) {\n    g.call(d3.axisLeft(y).tickSize(0).tickFormat(this.yFormat));\n  }\n\n  grid(g, x, y) {\n    // Separating the grid from the axes allows more control of its positioning\n    g.call(d3.axisLeft(y).tickSize(-this.layout.innerWidth).tickFormat(\"\"))\n      .selectAll(\".tick\")\n      .each(function (d) {\n        d3.select(this).classed(\"zero\", d === 0);\n      });\n  }\n\n  updateLayout() {\n    // Scales are needed to calculate the axes size, which may change layout and\n    // require scales to be re-calculated\n    const [xLabelWidth, xLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.xScale,\n      this.xFormat,\n      \"x axis\",\n    );\n    this.layout.pad.bottom = d3.max([this.layout.pad.bottom, xLabelHeight]);\n\n    const [yLabelWidth, yLabelHeight] = maxLabelSize(\n      this.svg,\n      this.layout,\n      this.yScale,\n      this.yFormat,\n      \"y axis\",\n    );\n\n    this.layout.pad.left = d3.max([\n      this.layout.pad.left,\n      yLabelWidth + this.config.MARGIN_TICK + 5,\n    ]);\n  }\n\n  render(selector) {\n    // If there is no data, do not render\n    if (!this.data.length) return;\n\n    // The selector can either be for an:\n    // 1. SVG element with width and height attributes\n    // 2. HTML element that has an intrinsic width - an SVG element will be created\n    [this.svg, this.layout] = layoutSVG(\n      selector,\n      this.config.LAYOUT,\n      this.config.OVERFLOW,\n    );\n\n    // Create fake axes to measure label sizes and update layout\n    this.updateLayout();\n\n    const x = this.xScale;\n    const y = this.yScale;\n\n    this.gGrid = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"grid\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    this.gInner = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"inner\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left}, ${this.layout.pad.top})`,\n      );\n\n    this.gx = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.innerHeight + this.layout.pad.top})`,\n      );\n\n    this.gy = this.svg\n      .append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .attr(\n        \"transform\",\n        `translate(${this.layout.pad.left},${this.layout.pad.top})`,\n      );\n\n    const grouping = d3.group(this.data, (d) => d.z);\n\n    this.paths = this.gInner\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH)\n      .selectAll(\"path\")\n      .data(grouping)\n      .join(\"path\");\n\n    const zoomed = ({ transform }) => {\n      this.x = transform.rescaleX(x).interpolate(d3.interpolateRound);\n      this.y = transform.rescaleY(y).interpolate(d3.interpolateRound);\n      this.update(this.x, this.y);\n    };\n\n    this.zoom = d3\n      .zoom()\n      .scaleExtent(this.config.ZOOM_EXTENT)\n      .on(\"zoom\", zoomed.bind(this));\n\n    // Dot - shows nearest point during pointer events\n    this.dot = this.gInner\n      .append(\"g\")\n      .attr(\"class\", \"dot\")\n      .style(\"display\", \"none\");\n    this.circle = this.dot.append(\"circle\").attr(\"r\", this.config.DOT_RADIUS);\n\n    this.reset();\n  }\n\n  update(x, y) {\n    // Hide the chart if there's no visible data\n    if (!this.visibleData.length) {\n      this.gx.attr(\"opacity\", 0.0);\n      this.gy.attr(\"opacity\", 0.0);\n      this.paths.attr(\"opacity\", 0.0);\n      return;\n    }\n\n    // Re-draw the chart with the new x and y scales\n    this.hideDot();\n    this.gx.call(this.xAxis.bind(this), x).attr(\"opacity\", 1.0);\n    this.gy.call(this.yAxis.bind(this), y).attr(\"opacity\", 1.0);\n    this.gGrid.call(this.grid.bind(this), x, y);\n\n    // Plot the line\n    const line = d3\n      .line()\n      .digits(2)\n      .defined(this.defined)\n      .x((d) => x(d.x))\n      .y((d) => y(d.y));\n\n    this.paths\n      .attr(\"d\", ([, I]) => line(I))\n      .attr(\"stroke\", ([z]) => this.colors(z))\n      .attr(\"class\", ([z]) => className(z))\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0));\n  }\n\n  reset() {\n    const z = this.svg\n      .call(this.zoom)\n      .call(this.zoom.transform, d3.zoomIdentity);\n\n    if (this.zoomIsDisabled) {\n      // Disable zoom completely if requested\n      z.on(\"mousedown.zoom\", null)\n        .on(\"touchstart.zoom\", null)\n        .on(\"touchmove.zoom\", null)\n        .on(\"touchend.zoom\", null);\n    }\n  }\n\n  placeDot(index) {\n    // Place a dot at the given index\n    const d = this.data[index];\n    this.dot\n      .style(\"display\", null)\n      .attr(\"transform\", `translate(${this.x(d.x)},${this.y(d.y)})`);\n    this.circle.attr(\"fill\", this.colors(d.z));\n  }\n\n  hideDot() {\n    this.dot.style(\"display\", \"none\");\n  }\n\n  noHighlight() {\n    // Reset all lines to default\n    this.paths\n      .attr(\"opacity\", ([z]) => (this.hidden.has(z) ? 0 : 1.0))\n      .attr(\"stroke-width\", this.config.STROKE_WIDTH);\n  }\n\n  highlight(z) {\n    // Hide paths that aren't the currently selected path\n    this.paths\n      .attr(\"opacity\", ([elem]) => {\n        if (this.hidden.has(elem)) return 0;\n        return elem === z ? 1.0 : this.config.BACKGROUND_OPACITY;\n      })\n      .attr(\"stroke-width\", ([elem]) =>\n        elem === z\n          ? this.config.HIGHLIGHT_STROKE_WIDTH\n          : this.config.STROKE_WIDTH,\n      );\n  }\n\n  onEvent(move, leave) {\n    // let prevIndex = null;\n\n    const pointermove = (evt) => {\n      if (evt.touches) {\n        // Prevent scroll on touch devices\n        evt.preventDefault();\n        evt = evt.touches[0];\n      }\n\n      const [xm, ym] = d3.pointer(evt, this.gInner.node());\n\n      // Determine the closest point to the cursor\n      // TODO Points could be memoized based on hidden z items\n      const points = d3.map(this.data, (d) => {\n        if (this.hidden.has(d.z)) return null;\n        return Math.hypot(this.x(d.x) - xm, this.y(d.y) - ym);\n      });\n\n      const index = d3.leastIndex(points);\n      if (index === -1 || points[index] === null) return;\n\n      // Exit early if no point was found\n      if (typeof index === \"undefined\") return;\n\n      // TODO To only trigger the callback when the index changes\n      // if (prevIndex && prevIndex == index) return;\n\n      this.placeDot(index);\n\n      const d = this.data[index];\n\n      // Data that will be provided to the callback: include both the coordinates\n      // of the dot and the pointer, both in relation to the page\n      const [dx, dy] = pageXY(this.dot.node());\n      const [px, py] = d3.pointer(evt, null);\n\n      let data = {\n        x: d.x,\n        y: d.y,\n        z: d.z,\n        // Dot page coordinates\n        dx: dx,\n        dy: dy,\n        // Pointer page coordinates\n        px: px,\n        py: py,\n      };\n\n      if (move) {\n        move.call(this, data);\n      }\n    };\n\n    const pointerleave = (evt) => {\n      this.hideDot();\n      if (leave) {\n        leave.call(this);\n      }\n    };\n\n    // Separate mouse and touch events\n    this.svg\n      .on(\"mousemove\", throttle(pointermove, 1000.0 / this.config.FPS))\n      .on(\"mouseleave\", pointerleave)\n      .on(\"touchstart\", pointermove, { passive: false })\n      .on(\"touchmove\", throttle(pointermove, 1000.0 / this.config.FPS), {\n        passive: false,\n      })\n      .on(\"touchend\", pointerleave, { passive: false });\n  }\n\n  hide(...z) {\n    // Add the given z elements to the hidden set\n    this.hidden = this.hidden.union(new Set(z));\n    this.toggle();\n  }\n\n  show(...z) {\n    // Remove the given z elements from the hidden set\n    this.hidden = this.hidden.difference(new Set(z));\n    this.toggle();\n  }\n\n  hideAll() {\n    this.hidden = new Set(this.Z);\n    this.toggle();\n  }\n\n  showAll() {\n    this.hidden = new Set();\n    this.toggle();\n  }\n\n  toggle() {\n    // Recalculate the scales based on the non-hidden items\n    this.x = this.xScale;\n    this.y = this.yScale;\n    this.update(this.x, this.y);\n  }\n\n  // TODO method to append a data point\n  append() {}\n}\n\nexport function LineWithZoom(data, parser) {\n  return new LineChartWithZoom(data, parser);\n}\n\nexport class TimeSeriesChartWithZoom extends LineChartWithZoom {\n  get xScale() {\n    return d3\n      .scaleUtc()\n      .domain(this.xDomain)\n      .range([0, this.layout.innerWidth]);\n  }\n}\n\nexport function TimeSeriesWithZoom(data, parser) {\n  return new TimeSeriesChartWithZoom(data, parser);\n}\n"],
  "mappings": "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",
  "names": ["require_d3", "__commonJSMin", "exports", "module", "rates_exports", "__export", "Rates", "d3", "d3", "animatedDashArray", "pattern", "totalLength", "dash", "dashLength", "count", "animatedDashOffset", "t", "d3", "d3", "d3", "quantizeScheme", "n", "scheme", "min", "max", "t", "Chart", "data", "parser", "d", "value", "CategoricalChart", "scheme", "min", "max", "quantizeScheme", "z", "d3", "Pad", "top", "right", "bottom", "left", "DefaultPad", "Pad", "Layout", "width", "height", "pad", "getLayout", "elem", "minWidth", "maxWidth", "minHeight", "maxHeight", "screenHeightPercent", "chart", "appendSVG", "selector", "width", "height", "overflow", "layoutSVG", "options", "elem", "svg", "Layout", "layout", "getLayout", "d3", "invalidChars", "invalidStart", "className", "value", "throttle", "fn", "timeout", "free", "d3", "maxLabelSize", "svg", "layout", "scale", "format", "cls", "hidden", "axis", "labels", "width", "height", "elem", "placeTooltip", "container", "tooltip", "dx", "dy", "padding", "bbox", "px", "py", "x", "y", "align", "pageXY", "node", "svg", "point", "rect", "d3", "d3", "month", "monthDay", "monthYear", "monthDayYear", "fullMonthDayYear", "quarter", "d", "d3", "d3", "percent", "percentChange", "magnitude", "units", "price", "d3", "getLength", "elem", "LineChart", "CategoricalChart", "data", "parser", "d", "__publicField", "z", "pattern", "visible", "i", "g", "x", "y", "xLabelWidth", "xLabelHeight", "maxLabelSize", "yLabelWidth", "yLabelHeight", "selector", "layoutSVG", "yTransform", "grouping", "isEmpty", "line", "I", "className", "lengths", "previousUpdate", "p", "animatedDashArray", "animatedDashOffset", "transition", "index", "move", "leave", "pointermove", "evt", "xm", "ym", "points", "dx", "dy", "pageXY", "px", "py", "pointerleave", "throttle", "TimeSeriesChart", "LineChart", "data", "a", "b", "parser", "d3", "d3", "d3", "d3", "parseRateArray", "d", "RatesChart", "TimeSeriesChart", "data", "__publicField", "selector", "tooltip", "names", "acc", "o", "onMove", "evt", "name", "q", "quarter", "percent", "percentChange", "pad", "tx", "ty", "align", "placeTooltip", "onLeave", "legend", "template", "item", "clone", "div", "z", "elem", "Rates"]
}
